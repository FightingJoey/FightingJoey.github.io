<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>乔羽的技术博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fightingjoey.github.io/"/>
  <updated>2019-03-04T06:34:17.661Z</updated>
  <id>https://fightingjoey.github.io/</id>
  
  <author>
    <name>乔羽 / FightingJoey</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift写时复制</title>
    <link href="https://fightingjoey.github.io/2019/01/22/%E5%BC%80%E5%8F%91/Swift%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/"/>
    <id>https://fightingjoey.github.io/2019/01/22/开发/Swift写时复制/</id>
    <published>2019-01-22T09:27:03.000Z</published>
    <updated>2019-03-04T06:34:17.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么会有写时复制"><a href="#为什么会有写时复制" class="headerlink" title="为什么会有写时复制"></a>为什么会有写时复制</h2><h3 id="为什么引入值类型"><a href="#为什么引入值类型" class="headerlink" title="为什么引入值类型"></a>为什么引入值类型</h3><p>在Swift中，Apple引入了值类型，相对于引用类型，值类型更加的高效和安全。</p><ol><li><p>值类型存储在栈上，引用类型存储在堆上，效率比较高</p></li><li><p>使用值类型，有可能在编译阶段就把问题暴露出来。比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = NSMutableArray.init(array: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], copyItems: false)</span><br><span class="line">arr1.removeObject(at: 0)</span><br><span class="line">//以上编译不会报错，由于arr1是引用类型，存储的是指针，指针不变就没问题，对指向的对象没有限制</span><br><span class="line"></span><br><span class="line">let arr2 = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line">arr2.remove(at: 0)</span><br><span class="line">//以上编译会报错，由于arr2是值类型</span><br></pre></td></tr></table></figure></li></ol><p><strong>值类型，即每个实例保持一份数据拷贝。</strong></p><p>在 Swift 中，典型的有 struct，enum，以及 tuple 都是值类型。而平时使用的 <code>Int</code>， <code>Double</code>， <code>Float</code>， <code>String</code>， <code>Array</code>， <code>Dictionary</code>，<code>Set</code> 其实都是用结构体实现的，也是值类型。</p><p>Swift 中，值类型的赋值为深拷贝（Deep Copy），值语义（Value Semantics）即新对象和源对象是独立的，当改变新对象的属性，源对象不会受到影响，反之同理。</p><p>如果声明一个值类型的<strong>常量</strong>，那么就意味着该常量是不可变的（无论内部数据为 <code>var</code>/<code>let</code>）。</p><p>这样看来一切都没问题，但是在写代码的时候，这些值类型每次赋值的时候真的是重新在内存中拷贝一份吗？如果一个数组里存了上万个元素，现在把它赋值给另一个变量，就必须要拷贝所有元素，即使这两个数组的内容是完全一致的，那可以预见这对性能会造成多么糟糕的影响。</p><p>既然我们能够想到这样的问题，那苹果的工程师肯定也想到了。如何才能避免不必要的复制呢，Swift给出了优化方案：<strong>Copy-On-Write</strong>（写时复制），即只有当这个值需要改变时才进行复制行为。在Swift标准库中，Array、Dictionary和Set都是通过写时复制来实现的。</p><h2 id="什么是写时复制？"><a href="#什么是写时复制？" class="headerlink" title="什么是写时复制？"></a>什么是写时复制？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x = [1,2,3]</span><br><span class="line">var y = x</span><br><span class="line">// 断点</span><br></pre></td></tr></table></figure><p>这个时候我们打印一下 x 和 y 的内存地址，这里我用的是 lldb 命令<code>fr v -R [object]</code> 来查看对象内存结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(lldb) fr v -R x</span><br><span class="line">(Swift.Array&lt;Swift.Int&gt;) x = &#123;</span><br><span class="line">  _buffer = &#123;</span><br><span class="line">    _storage = &#123;</span><br><span class="line">      rawValue = 0x0000600001c0ac40 &#123;</span><br><span class="line">          ......省略无用信息</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) fr v -R y</span><br><span class="line">(Swift.Array&lt;Swift.Int&gt;) y = &#123;</span><br><span class="line">  _buffer = &#123;</span><br><span class="line">    _storage = &#123;</span><br><span class="line">      rawValue = 0x0000600001c0ac40 &#123;</span><br><span class="line">          ......省略无用信息</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此我们可以看到 x 和 y 的内存地址都是<code>0x0000600001c0ac40</code>，说明 x 和 y 此时是共享同一个实例。这个时候我们再加上下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y.append(4)</span><br><span class="line">// 断点</span><br></pre></td></tr></table></figure><p>然后再打印一下地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(lldb) fr v -R x</span><br><span class="line">(Swift.Array&lt;Swift.Int&gt;) x = &#123;</span><br><span class="line">  _buffer = &#123;</span><br><span class="line">    _storage = &#123;</span><br><span class="line">      rawValue = 0x000060000126b180 &#123;</span><br><span class="line">          ......省略无用信息</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) fr v -R y</span><br><span class="line">(Swift.Array&lt;Swift.Int&gt;) y = &#123;</span><br><span class="line">  _buffer = &#123;</span><br><span class="line">    _storage = &#123;</span><br><span class="line">      rawValue = 0x0000600002301b60 &#123;</span><br><span class="line">          ......省略无用信息</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 x 和 y 的内存地址不在相同了，说明此时它们不再共享同一个实例，y 进行了数据拷贝。</p><p>Array 结构体内部含有指向某块内存的引用。这块内存就是用来存储数组中元素。x 和 y 两个数组一开始是共享同一块内存。不过，当我们改变 y 的时候，这个共享会被检测到，内存中的数据被拷贝出来，改变以后赋值给了 y。<strong>昂贵的元素复制操作只在必要的时候发生，这就是写时复制。</strong></p><h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><p>在结构体内部存储了一个指向实际数据的引用，在不进行修改操作的普通传递过程中，都是将内部的引用的引用计数+1，在进行修改时，对内部的引用做一次copy操作，再在这个复制出来的数据上进行真正的修改，从而保持其他的引用者不受影响。</p><h2 id="值类型嵌套引用类型"><a href="#值类型嵌套引用类型" class="headerlink" title="值类型嵌套引用类型"></a>值类型嵌套引用类型</h2><p>上面我们提到的 Array 内部元素是 Int，两者都是值类型，那么如果 Array 内部的元素是引用类型呢，情况会不会发生变化？我们一起来看一下~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;</span><br><span class="line">var name: String</span><br><span class="line">init(name: String) &#123;</span><br><span class="line">self.name = name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct School &#123;</span><br><span class="line">var student = Student(name: &quot;小明&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let school1 = School()</span><br><span class="line">var school2 = school1</span><br><span class="line">print(school1.student.name)</span><br><span class="line">print(school2.student.name)</span><br><span class="line">// 断点1</span><br><span class="line"></span><br><span class="line">school2.student.name = &quot;小红&quot;</span><br><span class="line">print(school1.student.name)</span><br><span class="line">print(school2.student.name)</span><br><span class="line">// 断点2</span><br><span class="line"></span><br><span class="line">school2.student = Student(name: &quot;小李&quot;)</span><br><span class="line">print(school1.student.name)</span><br><span class="line">print(school2.student.name)</span><br><span class="line">// 断点3</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">小明</span><br><span class="line">小明</span><br><span class="line">小红</span><br><span class="line">小红</span><br><span class="line">小红</span><br><span class="line">小李</span><br></pre></td></tr></table></figure><p>断点1，school1 和 school2 的内存结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(lldb) fr v -R school1</span><br><span class="line">(Copy_On_WriteTest.ViewController.School) school1 = &#123;</span><br><span class="line">  student = 0x00006000024053e0 &#123;</span><br><span class="line">    name = &#123;</span><br><span class="line">      _guts = &#123;</span><br><span class="line">        _object = &#123;</span><br><span class="line">          _object = 0x9000000105a02356</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) fr v -R school2</span><br><span class="line">(Copy_On_WriteTest.ViewController.School) school2 = &#123;</span><br><span class="line">  student = 0x00006000024053e0 &#123;</span><br><span class="line">    name = &#123;</span><br><span class="line">      _guts = &#123;</span><br><span class="line">        _object = &#123;</span><br><span class="line">          _object = 0x9000000105a02356</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>school1</code> 赋值给<code>school2</code> 后，<code>school1.student</code>和<code>school2.student</code>的内存地址都是<code>0x00006000024053e0</code>，其引用类型实例变量 <code>name</code> 的地址也都是 <code>0x9000000105a02356</code> ，它们共享同一个实例，其引用类型的实例变量也共享。</p><h3 id="1-修改结构体内引用类型的实例变量的值"><a href="#1-修改结构体内引用类型的实例变量的值" class="headerlink" title="1.修改结构体内引用类型的实例变量的值"></a>1.修改结构体内引用类型的实例变量的值</h3><p>断点2，school1 和 school2 的内存结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(lldb) fr v -R school1</span><br><span class="line">(Copy_On_WriteTest.ViewController.School) school1 = &#123;</span><br><span class="line">  student = 0x00006000024053e0 &#123;</span><br><span class="line">    name = &#123;</span><br><span class="line">      _guts = &#123;</span><br><span class="line">        _object = &#123;</span><br><span class="line">          _object = 0x9000000105a0235c</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) fr v -R school2</span><br><span class="line">(Copy_On_WriteTest.ViewController.School) school2 = &#123;</span><br><span class="line">  student = 0x00006000024053e0 &#123;</span><br><span class="line">    name = &#123;</span><br><span class="line">      _guts = &#123;</span><br><span class="line">        _object = &#123;</span><br><span class="line">          _object = 0x9000000105a0235c</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而执行<code>school2.student.name = &quot;小红&quot;</code> 后，<code>school1.student</code> 与 <code>school2.student</code> 的内存地址不变，其实例变量 <code>name</code> 内存地址都发生改变且相同，还是共享同一个实例变量，也就是说，虽然对值类型有所修改，但没有发生拷贝行为。</p><h3 id="2-修改结构体内引用类型的值"><a href="#2-修改结构体内引用类型的值" class="headerlink" title="2.修改结构体内引用类型的值"></a>2.修改结构体内引用类型的值</h3><p>断点3，school1 和 school2 的内存结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(lldb) fr v -R school1</span><br><span class="line">(Copy_On_WriteTest.ViewController.School) school1 = &#123;</span><br><span class="line">  student = 0x00006000024053e0 &#123;</span><br><span class="line">    name = &#123;</span><br><span class="line">      _guts = &#123;</span><br><span class="line">        _object = &#123;</span><br><span class="line">          _object = 0x9000000105a0235c</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) fr v -R school2</span><br><span class="line">(Copy_On_WriteTest.ViewController.School) school2 = &#123;</span><br><span class="line">  student = 0x0000600002405400 &#123;</span><br><span class="line">    name = &#123;</span><br><span class="line">      _guts = &#123;</span><br><span class="line">        _object = &#123;</span><br><span class="line">          _object = 0x9000000105a02362</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>school2.student</code> 和<code>school2.student.name</code> 的内存地址都发生变化，而<code>school1.student</code> 和<code>school1.student.name</code> 的内存地址不变，说明，此时对结构体进行了拷贝行为，而<code>student</code> 这个引用类型是直接指向另一个实例，而不是对原实例进行修改。</p><h2 id="自定义Struct如何实现写时复制"><a href="#自定义Struct如何实现写时复制" class="headerlink" title="自定义Struct如何实现写时复制"></a>自定义Struct如何实现写时复制</h2><p>作为一个结构体的作者，你并不能免费获得这种特性，你需要自己进行实现。当你自己的类型内部含有一个或多个可变引用，同时你想要保持值语义，并且避免不必要的复制时，为你的类型实现写时复制是有意义的。</p><p>在 Swift 中，我们可以使用 <code>isKnownUniquelyReferenced</code> 函数来检查某个引用只有一个持有者。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct School &#123;</span><br><span class="line">    private var student = Student(name: &quot;小明&quot;)</span><br><span class="line"></span><br><span class="line">    var studentName: String &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            return student.name</span><br><span class="line">        &#125;</span><br><span class="line">        set &#123;</span><br><span class="line">            if isKnownUniquelyReferenced(&amp;student) &#123;</span><br><span class="line">                student.name = newValue</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                student = Student(name: newValue)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么会有写时复制&quot;&gt;&lt;a href=&quot;#为什么会有写时复制&quot; class=&quot;headerlink&quot; title=&quot;为什么会有写时复制&quot;&gt;&lt;/a&gt;为什么会有写时复制&lt;/h2&gt;&lt;h3 id=&quot;为什么引入值类型&quot;&gt;&lt;a href=&quot;#为什么引入值类型&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>WKWebView进阶填坑指南-Swift</title>
    <link href="https://fightingjoey.github.io/2018/11/15/%E5%BC%80%E5%8F%91/WKWebView%E8%BF%9B%E9%98%B6%E5%A1%AB%E5%9D%91%E6%8C%87%E5%8D%97-Swift/"/>
    <id>https://fightingjoey.github.io/2018/11/15/开发/WKWebView进阶填坑指南-Swift/</id>
    <published>2018-11-15T03:47:35.000Z</published>
    <updated>2018-11-15T10:28:47.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cookie处理"><a href="#Cookie处理" class="headerlink" title="Cookie处理"></a>Cookie处理</h2><p>在设置<code>Cookie</code>的时候，我们经常做的是在请求的请求头里添加<code>Cookie</code>，但是这只是把<code>Cookie</code>发送给了服务端，我们本地并没有保存<code>Cookie</code>，<code>Cookie</code>最终要写到<code>WebView</code>的一个<code>Cookie</code>文件目录里面，后续<code>WebView</code>里面自己的发起的请求或者跳转才能在发起请求的时候在对应的域名下面取到<code>Cookie</code>传出去。</p><p><code>Webview</code>加载 H5 页面，实际上是把页面相关的<code>.html、js、css</code>文件下载到本地，然后再加载，这时页面去获取<code>Cookie</code> 的时候，是去本地<code>WebView</code>里的<code>Cookie</code>文件目录里查找，如果没有设置的话肯定就找不到了。所以在设置<code>Cookie</code>的时候，服务端和客户端都要设置。</p><h4 id="一、服务端-Cookie-设置"><a href="#一、服务端-Cookie-设置" class="headerlink" title="一、服务端 Cookie 设置"></a>一、服务端 Cookie 设置</h4><p>在使用<code>UIWebView</code>的时候，我们是通过<code>NSHTTPCookieStorage</code>来管理 <code>Cookie</code>的，下面我们给<code>devqiaoyu.tech</code>这个域名添加一个名为<code>user</code>的<code>Cookie</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var props = Dictionary&lt;HTTPCookiePropertyKey, Any&gt;()</span><br><span class="line">props[HTTPCookiePropertyKey.name] = &quot;user&quot;</span><br><span class="line">props[HTTPCookiePropertyKey.value] = &quot;admin&quot;</span><br><span class="line">props[HTTPCookiePropertyKey.path] = &quot;/&quot;</span><br><span class="line">props[HTTPCookiePropertyKey.domain] = &quot;devqiaoyu.tech&quot;</span><br><span class="line">props[HTTPCookiePropertyKey.version] = &quot;0&quot;</span><br><span class="line">props[HTTPCookiePropertyKey.originURL] = &quot;devqiaoyu.tech&quot;</span><br><span class="line">if let cookie = HTTPCookie(properties: props) &#123;</span><br><span class="line">    HTTPCookieStorage.shared.setCookie(cookie)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>WKWebView Cookie</code>问题在于<code>WKWebView</code>发起的请求不会自动带上存储于<code>NSHTTPCookieStorage</code>容器中的<code>Cookie</code>。</strong></p><p>解决办法也很简单，就是在<code>WKWebView</code>发起请求之前，先从<code>NSHTTPCookieStorage</code>读取<code>Cookie</code>，然后手动往<code>URLRequest</code>的请求头里添加一下<code>Cookie</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func getCookie() -&gt; String &#123;</span><br><span class="line">    var cookieString = &quot;&quot;</span><br><span class="line">if let cookies = HTTPCookieStorage.shared.cookies &#123;</span><br><span class="line">for cookie in cookies &#123;</span><br><span class="line">if cookie.domain == cookieDomain &#123;</span><br><span class="line">let str = &quot;\(cookie.name)=\(cookie.value)&quot;</span><br><span class="line">cookieString.append(&quot;\(str);&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return cookieString</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var request = URLRequest(url: URL(string: &quot;https://devqiaoyu.com&quot;))</span><br><span class="line">request.addValue(getCookie(), forHTTPHeaderField: &quot;Cookie&quot;)</span><br></pre></td></tr></table></figure><p>当服务器页面发生重定向的时候，此时第一次在<code>RequestHeader</code>中写入的<code>Cookie</code>会丢失，还需要对重定向的请求重新做添加<code>Cookie</code>的处理。具体方法请往下看~</p><h4 id="二、客户端-Cookie-设置"><a href="#二、客户端-Cookie-设置" class="headerlink" title="二、客户端 Cookie 设置"></a>二、客户端 Cookie 设置</h4><p>上面这么写完了，当页面加载的时候，后端无论是啥语言，都能从请求头里看到<code>Cookie</code>了，但是后端渲染返回页面后，在客户端的<code>WebView</code>里运行的时候，JS 在执行的时候调用<code>document.cookie</code> API 是读取不到<code>Cookie</code>的，所以还得针对客户端<code>Cookie</code>进行处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var cookieString = &quot;&quot;</span><br><span class="line">if let cookies = HTTPCookieStorage.shared.cookies &#123;</span><br><span class="line">for cookie in cookies &#123;</span><br><span class="line">if cookie.domain == &quot;devqiaoyu.tech&quot; &#123;</span><br><span class="line">let str = &quot;\(cookie.name)=\(cookie.value)&quot;</span><br><span class="line">cookieString.append(&quot;document.cookie=&apos;\(str);path=/;domain=devqiaoyu.tech&apos;;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let cookieScript = WKUserScript(source: cookieString, injectionTime: .atDocumentStart, forMainFrameOnly: false)</span><br><span class="line">let userContentController = WKUserContentController()</span><br><span class="line">userContentController.addUserScript(cookieScript)</span><br><span class="line"></span><br><span class="line">let webViewConfig = WKWebViewConfiguration()</span><br><span class="line">webViewConfig.userContentController = userContentController</span><br><span class="line"></span><br><span class="line">let webV = WKWebView(frame: CGRect.zero, configuration: webViewConfig)</span><br></pre></td></tr></table></figure><p><strong>客户端<code>Cookie</code>注入实际上就是创建一个 JS 脚本，让<code>WebView</code>去执行，推荐在<code>.atDocumentStart</code>这个时机进行预置静态  JS 的注入。</strong>这样<code>WebView</code>在加载后端返回的静态页面的时候，就可以拿到保存着客户端的<code>Cookie</code>了。</p><blockquote><p><strong>注意：document.cookie() 无法跨域设置 Cookie</strong>，比如你第一次加载的请求时 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> ，在重定向的时候跳转到了 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> ，那么第二个请求就可能因为没有携带 <code>Cookie</code>而无法访问。当然啦，解决办法还是有的，请往下看~</p></blockquote><h2 id="URL拦截"><a href="#URL拦截" class="headerlink" title="URL拦截"></a>URL拦截</h2><p>在<code>WKWebView</code>中，每一次页面跳转之前，都会调用下面的回调函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void)</span><br></pre></td></tr></table></figure><h4 id="Web-页面重定向问题"><a href="#Web-页面重定向问题" class="headerlink" title="Web 页面重定向问题"></a>Web 页面重定向问题</h4><p>重定向问题有两种：</p><ul><li>服务器页面重定向，需要对新发起的请求重新种<code>Cookie</code></li><li>本地页面重定向，只要客户端设置了<code>Cookie</code>，那么就不需要处理了</li></ul><p>所以如果是服务器页面重定向，那么判断此时<code>Request</code>是否有你要的<code>Cookie</code>没有就<code>Cancel</code>掉，修改<code>Request</code>重新发起。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void)</span><br><span class="line">&#123;</span><br><span class="line">    var shouldCancelLoadURL = false</span><br><span class="line">    if let cookie = navigationAction.request.value(forHTTPHeaderField: &quot;Cookie&quot;) &#123;</span><br><span class="line">        if cookie.contains(&quot;user&quot;) &#123;</span><br><span class="line">            shouldCancelLoadURL = false</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            var request = URLRequest(url: URL(string: (navigationAction.request.url?.absoluteString)!)!)</span><br><span class="line">            request.addValue(getCookie(), forHTTPHeaderField: &quot;Cookie&quot;)</span><br><span class="line">            webView.load(request)</span><br><span class="line">            shouldCancelLoadURL = true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var request = URLRequest(url: URL(string: (navigationAction.request.url?.absoluteString)!)!)</span><br><span class="line">        request.addValue(getCookie(), forHTTPHeaderField: &quot;Cookie&quot;)</span><br><span class="line">webView.load(request)</span><br><span class="line">shouldCancelLoadURL = true</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if shouldCancelLoadURL &#123;</span><br><span class="line">    decisionHandler(WKNavigationActionPolicy.cancel)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">decisionHandler(WKNavigationActionPolicy.allow)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h4><p>针对跨域的问题，解决办法和上面的方法类似，仅仅是判断条件不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -&gt; Void)</span><br><span class="line">&#123;</span><br><span class="line">    var shouldCancelLoadURL = false</span><br><span class="line">    if let url = navigationAction.request.url?.absoluteString &#123;</span><br><span class="line">        if url.contains(&quot;devqiaoyu.tech&quot;) &#123; // 原来的域名</span><br><span class="line">            shouldCancelLoadURL = false</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        // 重新发起请求，种Cookie</span><br><span class="line">            shouldCancelLoadURL = true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    // 重新发起请求，种Cookie</span><br><span class="line">shouldCancelLoadURL = true</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if shouldCancelLoadURL &#123;</span><br><span class="line">    decisionHandler(WKNavigationActionPolicy.cancel)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">decisionHandler(WKNavigationActionPolicy.allow)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="假跳转的请求拦截"><a href="#假跳转的请求拦截" class="headerlink" title="假跳转的请求拦截"></a>假跳转的请求拦截</h4><p><strong>一种 JS 调用 Native 的通信方案</strong>，详细介绍可以看<a href="http://www.cocoachina.com/ios/20180109/21795.html" target="_blank" rel="noopener">从零收拾一个hybrid框架（一）– 从选择JS通信方案开始</a>。下面内容是从该文章内摘录的。</p><p>何谓 <strong>假跳转的请求拦截</strong> 就是由网页发出一条新的跳转请求，跳转的目的地是一个非法的压根就不存在的地址，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//常规的Http地址</span><br><span class="line">https://wenku.baidu.com/xxxx?xx=xx</span><br><span class="line">//假的请求通信地址</span><br><span class="line">wakaka://wahahalalala/action?param=paramobj</span><br></pre></td></tr></table></figure><p>看我下面写的那条假跳转地址，这么一条什么都不是的扯淡地址，直接放到浏览器里，直接扔到<code>WebView</code>里，肯定是妥妥的什么都打不开的，而如果在经过我们改造过的<code>Hybrid WebView</code>里，进行拦截不进行跳转</p><p>url 地址分为这么几个部分</p><ul><li>协议：也就是 <code>http/https/file</code> 等，上面用了<code>wakaka</code></li><li>域名：上面的 <code>wenku.baidu.com</code> 或 <code>wahahalalala</code></li><li>路径：上面的 <code>xxxx?</code> 或 <code>action？</code></li><li>参数：上面的 <code>xx=xx</code> 或 <code>param=paramobj</code></li></ul><p>如果我们构建一条假url</p><ul><li>用协议与域名当做通信识别</li><li>用路径当做指令识别</li><li>用参数当做数据传递</li></ul><p>客户端会无差别拦截所有请求，真正的 url 地址应该照常放过，只有协议域名匹配的 url 地址才应该被客户端拦截，拦截下来的 url 不会导致 WebView 继续跳转错误地址，因此无感知，相反拦截下来的 url 我们可以读取其中路径当做指令，读取其中参数当做数据，从而根据约定调用对应的 Native 原生代码</p><p>以上其实是一种 <strong>协议约定</strong> 只要 JS 侧按着这个约定协议生成假 url，Native 按着约定协议拦截/读取假 url，整个流程就能跑通。</p><h2 id="User-Agent设置"><a href="#User-Agent设置" class="headerlink" title="User-Agent设置"></a>User-Agent设置</h2><h4 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h4><p>就是<code>App</code>内所有<code>Web</code>请求的<code>User-Agent</code>全部被修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// UIWebView</span><br><span class="line">let webView = UIWebView(frame: CGRect.zero)</span><br><span class="line">let userAgent = webView.stringByEvaluatingJavaScript(from: &quot;navigator.userAgent&quot;)</span><br><span class="line">if let agent = userAgent &#123;</span><br><span class="line">    let user = &quot;@\(agent);extra_user_agent&quot;</span><br><span class="line">    let dict = [&quot;UserAgent&quot;:user]</span><br><span class="line">    UserDefaults.standard.register(defaults: dict)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// WKWebView</span><br><span class="line">let webV = WKWebView(frame: CGRect.zero)</span><br><span class="line">webV.evaluateJavaScript(&quot;navigator.userAgent&quot;) &#123; (result, error) in</span><br><span class="line">if let oldAgent = result as? String &#123;</span><br><span class="line">let user = &quot;@\(oldAgent);extra_user_agent&quot;</span><br><span class="line">let dict = [&quot;UserAgent&quot;:user]</span><br><span class="line">UserDefaults.standard.register(defaults: dict)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单个WebView设置"><a href="#单个WebView设置" class="headerlink" title="单个WebView设置"></a>单个WebView设置</h3><p>在<code>iOS9</code>，<code>WKWebView</code>提供了一个非常便捷的属性去更改<code>User-Agent</code>，就是<code>customUserAgent</code>属性。这样使用起来不仅方便，也不会全局更改<code>User-Agent</code>，可惜的是<code>iOS9</code>才有，如果适配<code>iOS8</code>，还是要使用上面的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let webView = UIWebView(frame: CGRect.zero)</span><br><span class="line">let userAgent = webView.stringByEvaluatingJavaScript(from: &quot;navigator.userAgent&quot;)</span><br><span class="line">if let agent = userAgent &#123;</span><br><span class="line">    let user = &quot;@\(agent);extra_user_agent&quot;</span><br><span class="line">    webView.customUserAgent = user</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.jianshu.com/p/06963b57d78e" target="_blank" rel="noopener">WKWebView 那些坑</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Cookie处理&quot;&gt;&lt;a href=&quot;#Cookie处理&quot; class=&quot;headerlink&quot; title=&quot;Cookie处理&quot;&gt;&lt;/a&gt;Cookie处理&lt;/h2&gt;&lt;p&gt;在设置&lt;code&gt;Cookie&lt;/code&gt;的时候，我们经常做的是在请求的请求头里添加&lt;co
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>纯Swift项目基础第三方库</title>
    <link href="https://fightingjoey.github.io/2018/11/02/%E5%BC%80%E5%8F%91/%E7%BA%AFSwift%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    <id>https://fightingjoey.github.io/2018/11/02/开发/纯Swift项目基础第三方库/</id>
    <published>2018-11-02T09:08:23.000Z</published>
    <updated>2018-11-17T04:19:26.715Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络框架"><a href="#网络框架" class="headerlink" title="网络框架"></a>网络框架</h3><ul><li><a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">Moya</a> - 用 Swift 写的网络抽象层</li><li><a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="noopener">Alamofire</a></li></ul><h3 id="Keychain"><a href="#Keychain" class="headerlink" title="Keychain"></a>Keychain</h3><ul><li><a href="https://github.com/kishikawakatsumi/KeychainAccess" target="_blank" rel="noopener">KeychainAccess</a></li></ul><h3 id="JSON解析"><a href="#JSON解析" class="headerlink" title="JSON解析"></a>JSON解析</h3><ul><li><a href="https://github.com/alibaba/HandyJSON" target="_blank" rel="noopener"><strong>HandyJSON</strong></a> - 一个方便的swift json-object 序列化/反序列化库</li></ul><h3 id="UserDefaults"><a href="#UserDefaults" class="headerlink" title="UserDefaults"></a>UserDefaults</h3><ul><li><a href="https://github.com/radex/SwiftyUserDefaults" target="_blank" rel="noopener">SwiftyUserDefaults</a> - NSUserDefaults 的现代化 Swift API</li></ul><h3 id="图片解析加载"><a href="#图片解析加载" class="headerlink" title="图片解析加载"></a>图片解析加载</h3><ul><li><a href="https://github.com/onevcat/Kingfisher" target="_blank" rel="noopener">Kingfisher</a> - 是一个轻量、纯 Swift 的库，可以从网络中异步下载和缓存图片</li></ul><h3 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h3><ul><li><a href="https://github.com/krzyzanowskim/CryptoSwift" target="_blank" rel="noopener">CryptoSwift</a> - 是一个不断扩充的集合，包含了标准、安全、用 Swift 实现的加密算法</li></ul><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><ul><li><a href="https://github.com/SnapKit/SnapKit" target="_blank" rel="noopener">Snapkit</a></li></ul><h3 id="富文本"><a href="#富文本" class="headerlink" title="富文本"></a>富文本</h3><ul><li><a href="https://github.com/KyoheiG3/AttributedLabel" target="_blank" rel="noopener">AttributedLabel</a> - 显示性能数量级 UILabel 的 AttributedLabel</li></ul><h3 id="键盘类"><a href="#键盘类" class="headerlink" title="键盘类"></a>键盘类</h3><ul><li><a href="https://github.com/hackiftekhar/IQKeyboardManager" target="_blank" rel="noopener">IQKeyboardManagerSwift</a></li></ul><h3 id="提示框"><a href="#提示框" class="headerlink" title="提示框"></a>提示框</h3><ul><li><a href="https://github.com/scalessec/Toast-Swift" target="_blank" rel="noopener">Toast-Swift</a></li></ul><h3 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h3><ul><li><a href="https://github.com/LeoMobileDeveloper/PullToRefreshKit" target="_blank" rel="noopener">PullToRefreshKit</a></li></ul><h3 id="SegmentControl"><a href="#SegmentControl" class="headerlink" title="SegmentControl"></a>SegmentControl</h3><ul><li><a href="https://github.com/HeshamMegid/HMSegmentedControl-Swift" target="_blank" rel="noopener">HMSegmentedControl-Swift</a></li></ul><h3 id="空页面"><a href="#空页面" class="headerlink" title="空页面"></a>空页面</h3><ul><li><a href="https://github.com/Xiaoye220/EmptyDataSet-Swift" target="_blank" rel="noopener">DZNEmptyDataSet-Swift</a> - 空页面视图框架</li></ul><h3 id="TabBarController"><a href="#TabBarController" class="headerlink" title="TabBarController"></a>TabBarController</h3><ul><li><a href="https://github.com/chenjiang3/RDVTabBarControllerSwift" target="_blank" rel="noopener">RDVTabBarControllerSwift</a> - 一个定制化的TabBarController库，可动画显示隐藏tabbar栏，可定制tabbar栏</li></ul><h3 id="HUD"><a href="#HUD" class="headerlink" title="HUD"></a>HUD</h3><ul><li><a href="https://github.com/pkluz/PKHUD" target="_blank" rel="noopener">PKHUD</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;网络框架&quot;&gt;&lt;a href=&quot;#网络框架&quot; class=&quot;headerlink&quot; title=&quot;网络框架&quot;&gt;&lt;/a&gt;网络框架&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Moya/Moya&quot; target=&quot;_blank&quot; r
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用Carthage发布自己创建的Framework并使用</title>
    <link href="https://fightingjoey.github.io/2018/11/01/%E5%BC%80%E5%8F%91/%E4%BD%BF%E7%94%A8Carthage%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E5%88%9B%E5%BB%BA%E7%9A%84Framework%E5%B9%B6%E4%BD%BF%E7%94%A8/"/>
    <id>https://fightingjoey.github.io/2018/11/01/开发/使用Carthage发布自己创建的Framework并使用/</id>
    <published>2018-11-01T06:03:01.000Z</published>
    <updated>2018-11-01T09:02:45.393Z</updated>
    
    <content type="html"><![CDATA[<p>Xcode 9.4.1</p><h3 id="创建Framework"><a href="#创建Framework" class="headerlink" title="创建Framework"></a>创建Framework</h3><h4 id="1-新建工程"><a href="#1-新建工程" class="headerlink" title="1.新建工程"></a>1.新建工程</h4><p>打开Xcode，<code>command+n</code>新建工程，选择<code>Cocoa Touch Framework</code>，点击<code>next</code>，命名为<code>StringExtension</code>。</p><p><img src="https://upload-images.jianshu.io/upload_images/1507703-3c0354763891ca67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建Framework"></p><h4 id="2-创建文件"><a href="#2-创建文件" class="headerlink" title="2.创建文件"></a>2.创建文件</h4><p><code>StringExtension.swift</code>是不准备暴露出去的，<code>Test.swift</code>是准备暴露出去给外界调用的。</p><p><img src="https://upload-images.jianshu.io/upload_images/1507703-1031b7b70e723eb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="StringExtension"></p><p><img src="https://upload-images.jianshu.io/upload_images/1507703-ba0335fa34807f4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="test"></p><p><strong>需要暴露出来给外界调用的类或方法必须要加上关键字<code>public</code>。</strong></p><h4 id="3-将Scheme设置为shared"><a href="#3-将Scheme设置为shared" class="headerlink" title="3.将Scheme设置为shared"></a>3.将<code>Scheme</code>设置为<code>shared</code></h4><p><img src="https://upload-images.jianshu.io/upload_images/1507703-e330b4d9de92f995.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="scheme"></p><h4 id="4-使用Carthage构建Framework"><a href="#4-使用Carthage构建Framework" class="headerlink" title="4.使用Carthage构建Framework"></a>4.使用<code>Carthage</code>构建<code>Framework</code></h4><p>终端进入工程目录下，执行下面代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ carthage build --no-skip-current</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1507703-302991dc8145b2f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="carthage build"></p><p>执行完成以后会发现，目录下多了一个<code>Carthage</code>文件夹，我们的<code>Framework</code>就在该文件夹里面。</p><p><img src="https://upload-images.jianshu.io/upload_images/1507703-ca81ab8e03318441.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="framework"></p><h3 id="将Framework上传至Github"><a href="#将Framework上传至Github" class="headerlink" title="将Framework上传至Github"></a>将Framework上传至Github</h3><h4 id="1-新建仓库"><a href="#1-新建仓库" class="headerlink" title="1.新建仓库"></a>1.新建仓库</h4><p><img src="https://upload-images.jianshu.io/upload_images/1507703-a94c25ef68b39bfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="new repository"></p><h4 id="2-初始化仓库"><a href="#2-初始化仓库" class="headerlink" title="2.初始化仓库"></a>2.初始化仓库</h4><p>终端进入工程目录下，执行下面代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;# StringExtension&quot; &gt;&gt; README.md</span><br><span class="line">$ git init</span><br><span class="line">$ git add README.md</span><br><span class="line">$ git commit -m &quot;first commit&quot;</span><br><span class="line">$ git remote add origin https://github.com/Geselle-Joy/StringExtension.git</span><br><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1507703-cd262fac12adef0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="setup.png"></p><h4 id="3-添加gitignore"><a href="#3-添加gitignore" class="headerlink" title="3.添加gitignore"></a>3.添加gitignore</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ touch .gitignore #这句话只是创建了gitignore文件，记得要打开添加内容</span><br><span class="line">$ git add .gitignore</span><br><span class="line">$ git commit -m &quot;add gitignore&quot;</span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure><h4 id="4-添加工程文件"><a href="#4-添加工程文件" class="headerlink" title="4.添加工程文件"></a>4.添加工程文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m &quot;add StringExtension&quot;</span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure><h4 id="5-添加版本标记"><a href="#5-添加版本标记" class="headerlink" title="5.添加版本标记"></a>5.添加版本标记</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag 1.0.0</span><br><span class="line">$ git push --tags</span><br></pre></td></tr></table></figure><p>到这里我们自己创建的<code>framework</code>已经上传到<code>github</code>上了。</p><h3 id="调用我们创建的Framework"><a href="#调用我们创建的Framework" class="headerlink" title="调用我们创建的Framework"></a>调用我们创建的Framework</h3><h4 id="1-用Xcode创建新项目"><a href="#1-用Xcode创建新项目" class="headerlink" title="1.用Xcode创建新项目"></a>1.用Xcode创建新项目</h4><p>创建项目，cd到工程目录</p><h4 id="2-创建一个空的carthage文件"><a href="#2-创建一个空的carthage文件" class="headerlink" title="2.创建一个空的carthage文件"></a>2.创建一个空的carthage文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch Cartfile</span><br></pre></td></tr></table></figure><h4 id="3-编辑Cartfile文件"><a href="#3-编辑Cartfile文件" class="headerlink" title="3.编辑Cartfile文件"></a>3.编辑Cartfile文件</h4><p>编辑<code>Cartfile</code>文件，输入如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github &quot;Geselle-Joy/StringExtension&quot;</span><br></pre></td></tr></table></figure><p>版本含义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~&gt; 3.0 表示使用版本3.0以上但是低于4.0的最新版本，如3.5, 3.9</span><br><span class="line">== 3.0 表示使用3.0版本</span><br><span class="line">&gt;= 3.0 表示使用3.0或更高的版本</span><br><span class="line"></span><br><span class="line">如果你没有指明版本号，则会自动使用最新的版本</span><br></pre></td></tr></table></figure><h4 id="4-保存并关闭Cartfile文件，在终端执行命令"><a href="#4-保存并关闭Cartfile文件，在终端执行命令" class="headerlink" title="4.保存并关闭Cartfile文件，在终端执行命令"></a>4.保存并关闭Cartfile文件，在终端执行命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ carthage update --platform iOS</span><br></pre></td></tr></table></figure><p>安装过程如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ testss carthage update --platform iOS</span><br><span class="line">*** Cloning StringExtension</span><br><span class="line">*** Checking out StringExtension at &quot;1.0.0&quot;</span><br><span class="line">*** xcodebuild output can be found in /var/folders/8w/s8bn_8c56p9czz75nqdqmp2m0000gn/T/carthage-xcodebuild.ecw6rz.log</span><br><span class="line">*** Building scheme &quot;StringExtension&quot; in StringExtension.xcodeproj</span><br></pre></td></tr></table></figure><p><code>carthage</code>会为你下载和编译所需要的第三方库，当命令执行完毕，在你的项目文件夹中会出现一个名为<code>Carthage</code>的文件夹和<code>Cartfile.resolved</code>的文件。</p><p>在<code>~/Carthage/Build/iOS</code>文件夹里就可以看到我们自己创建的<code>StringExtension.framework</code>了。</p><h4 id="5-导入framework"><a href="#5-导入framework" class="headerlink" title="5.导入framework"></a>5.导入framework</h4><p>打开你的项目，选择<code>target</code>, 再选择上方的<code>General</code>，将需要的<code>framework</code>文件拖到 <code>Linked frameworks and Binaries</code>内。</p><p><img src="https://upload-images.jianshu.io/upload_images/1507703-1a87f2488b9913a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="import framework"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Xcode 9.4.1&lt;/p&gt;
&lt;h3 id=&quot;创建Framework&quot;&gt;&lt;a href=&quot;#创建Framework&quot; class=&quot;headerlink&quot; title=&quot;创建Framework&quot;&gt;&lt;/a&gt;创建Framework&lt;/h3&gt;&lt;h4 id=&quot;1-新建工程&quot;&gt;&lt;a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>项目已添加到Git上以后再添加gitignore</title>
    <link href="https://fightingjoey.github.io/2018/11/01/%E6%95%99%E7%A8%8B/%E9%A1%B9%E7%9B%AE%E5%B7%B2%E6%B7%BB%E5%8A%A0%E5%88%B0Git%E4%B8%8A%E4%BB%A5%E5%90%8E%E5%86%8D%E6%B7%BB%E5%8A%A0gitignore/"/>
    <id>https://fightingjoey.github.io/2018/11/01/教程/项目已添加到Git上以后再添加gitignore/</id>
    <published>2018-11-01T03:02:18.000Z</published>
    <updated>2018-11-01T03:21:15.304Z</updated>
    
    <content type="html"><![CDATA[<p>接手别人的项目的时候，总是发现<code>gitignore</code>并没有设置或者设置的有问题，所以需要对<code>gitignore</code>进行添加或更新。</p><h4 id="1-为避免冲突，先拉取下远程仓库"><a href="#1-为避免冲突，先拉取下远程仓库" class="headerlink" title="1.为避免冲突，先拉取下远程仓库"></a>1.为避免冲突，先拉取下远程仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><h4 id="2-清除本地目录下的缓存"><a href="#2-清除本地目录下的缓存" class="headerlink" title="2.清除本地目录下的缓存"></a>2.清除本地目录下的缓存</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br></pre></td></tr></table></figure><h4 id="3-新建或更新-gitignore文件"><a href="#3-新建或更新-gitignore文件" class="headerlink" title="3.新建或更新.gitignore文件"></a>3.新建或更新<code>.gitignore</code>文件</h4><p>在项目的根目录下创建<code>.gitignore</code>文件，并添加相应的过滤规则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim .gitignore</span><br></pre></td></tr></table></figure><blockquote><p>这里推荐一个网站：<a href="https://www.gitignore.io" target="_blank" rel="noopener">gitignore.io</a>，可以根据你项目的需要获取<code>gitignore</code></p><p>或者也可以去 <a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a> 上找对应的<code>gitignore</code></p></blockquote><h4 id="4-再次添加所有文件到本地仓库缓存中"><a href="#4-再次添加所有文件到本地仓库缓存中" class="headerlink" title="4.再次添加所有文件到本地仓库缓存中"></a>4.再次添加所有文件到本地仓库缓存中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><h4 id="5-添加commit"><a href="#5-添加commit" class="headerlink" title="5.添加commit"></a>5.添加<code>commit</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;add gitignore&quot;</span><br></pre></td></tr></table></figure><h4 id="6-提交到远程仓库"><a href="#6-提交到远程仓库" class="headerlink" title="6.提交到远程仓库"></a>6.提交到远程仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接手别人的项目的时候，总是发现&lt;code&gt;gitignore&lt;/code&gt;并没有设置或者设置的有问题，所以需要对&lt;code&gt;gitignore&lt;/code&gt;进行添加或更新。&lt;/p&gt;
&lt;h4 id=&quot;1-为避免冲突，先拉取下远程仓库&quot;&gt;&lt;a href=&quot;#1-为避免冲突，先拉
      
    
    </summary>
    
    
      <category term="Git" scheme="https://fightingjoey.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>如何验证生产环境Push推送</title>
    <link href="https://fightingjoey.github.io/2018/10/22/%E5%BC%80%E5%8F%91/%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83Push%E6%8E%A8%E9%80%81/"/>
    <id>https://fightingjoey.github.io/2018/10/22/开发/如何验证生产环境Push推送/</id>
    <published>2018-10-22T07:51:50.000Z</published>
    <updated>2018-10-22T14:12:57.905Z</updated>
    
    <content type="html"><![CDATA[<p>在测试推送的时候，发现在测试环境测试的时候，是没有问题的，不论APP在前台还是在后台都可以收到推送，但是在生产环境，一直收不到推送。查了查资料后了解到，在生产换成测推送的时候，需要生成Ad-Hoc Profile。</p><h4 id="生成Ad-Hoc-Profile"><a href="#生成Ad-Hoc-Profile" class="headerlink" title="生成Ad-Hoc Profile"></a>生成Ad-Hoc Profile</h4><p>生成Profile，下载安装</p><p><img src="https://upload-images.jianshu.io/upload_images/1507703-a058376fc6c46af1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Ad-Hoc"></p><h4 id="更改Scheme"><a href="#更改Scheme" class="headerlink" title="更改Scheme"></a>更改Scheme</h4><ul><li><code>Product</code> —&gt;<code>Scheme</code> —&gt;<code>Edit Scheme</code></li><li>更改<code>Build Configuration</code>为<code>Release</code></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1507703-30fbde1369cd1da1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="scheme"></p><h4 id="更改Signing"><a href="#更改Signing" class="headerlink" title="更改Signing"></a>更改Signing</h4><p>选中自己刚才生成的<code>Profile</code></p><p><img src="https://upload-images.jianshu.io/upload_images/1507703-d2f8ebdeafe8ece4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="signing"></p><h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><p><code>Product</code> —&gt; <code>Archive</code>，等打包完成后，<code>Window</code> —&gt; <code>Organizer</code>，选择你刚才打的包。</p><p><img src="https://upload-images.jianshu.io/upload_images/1507703-55f4df85ce2a4f28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="archive"></p><p>选择<code>Export</code>。</p><p><img src="https://upload-images.jianshu.io/upload_images/1507703-f2269d84ef7b7b6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="export"></p><p>选择<code>Ad Hoc</code>。然后一步一步导出<code>ipa</code>包。拿到<code>ipa</code>包以后，使用<code>itools</code>安装至真机上，开始测试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在测试推送的时候，发现在测试环境测试的时候，是没有问题的，不论APP在前台还是在后台都可以收到推送，但是在生产环境，一直收不到推送。查了查资料后了解到，在生产换成测推送的时候，需要生成Ad-Hoc Profile。&lt;/p&gt;
&lt;h4 id=&quot;生成Ad-Hoc-Profile&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>升级Xcode10后遇到的问题</title>
    <link href="https://fightingjoey.github.io/2018/10/11/%E5%BC%80%E5%8F%91/%E5%8D%87%E7%BA%A7Xcode10%E5%90%8E%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://fightingjoey.github.io/2018/10/11/开发/升级Xcode10后遇到的问题/</id>
    <published>2018-10-11T09:38:14.000Z</published>
    <updated>2018-10-16T06:01:52.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Multiple-commands-produce"><a href="#1-Multiple-commands-produce" class="headerlink" title="1. Multiple  commands produce"></a>1. Multiple  commands produce</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Multiple commands produce &apos;/Users/joy/Library/Developer/Xcode/DerivedData/FKY-cpdtnacrrykispgfanfwxzyhrnge/Build/Products/Debug-iphonesimulator/FKY-TEST.app/Info.plist&apos;:</span><br><span class="line">1) Target &apos;FKY-TEST&apos; (project &apos;FKY&apos;) has copy command from &apos;/Users/joy/Documents/1药网Git/fangkuaiyi_ios/FKY/FKYSwift/Vendor/SKPhotoBrowser/Info.plist&apos; to &apos;/Users/joy/Library/Developer/Xcode/DerivedData/FKY-cpdtnacrrykispgfanfwxzyhrnge/Build/Products/Debug-iphonesimulator/FKY-TEST.app/Info.plist&apos;</span><br><span class="line">2) Target &apos;FKY-TEST&apos; (project &apos;FKY&apos;) has copy command from &apos;/Users/joy/Documents/1药网Git/fangkuaiyi_ios/FKY/Supporting Files/Info.plist&apos; to &apos;/Users/joy/Library/Developer/Xcode/DerivedData/FKY-cpdtnacrrykispgfanfwxzyhrnge/Build/Products/Debug-iphonesimulator/FKY-TEST.app/Info.plist&apos;</span><br><span class="line">3) Target &apos;FKY-TEST&apos; (project &apos;FKY&apos;) has process command with output &apos;/Users/joy/Library/Developer/Xcode/DerivedData/FKY-cpdtnacrrykispgfanfwxzyhrnge/Build/Products/Debug-iphonesimulator/FKY-TEST.app/Info.plist&apos;</span><br></pre></td></tr></table></figure><p>报错原因：<strong>重复</strong></p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>修改 Xcode 的配置暂时解决了编译报错的问题。</p><p><code>Xcode</code> -&gt; <code>File</code> -&gt; <code>Workspace settings</code> -&gt; <code>Build System</code>，选择 <code>Legacy Build System</code> 。</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><ol><li>选择打开所在的项目<code>Target</code> -&gt; <code>Build Phases</code> -&gt; <code>Copy Bundle Resources</code> </li><li>删除报错的那些文件</li></ol><h2 id="2-library-not-found-for-lstdc-6-0-9"><a href="#2-library-not-found-for-lstdc-6-0-9" class="headerlink" title="2. library not found for -lstdc++.6.0.9"></a>2. library not found for -lstdc++.6.0.9</h2><p>Xcode10不支持<code>libstdc++</code>系列的库了、需要删掉并且换成<code>libc++</code>系列的库。有些第三方由于没有更新，会牵扯到这个库，所以运行后报错。</p><h3 id="方案一-1"><a href="#方案一-1" class="headerlink" title="方案一"></a>方案一</h3><p>打开<code>Build Phases</code> -&gt; <code>Link Binary With Libraries</code>，删除<code>lstdc++.6.0.9</code>依赖</p><blockquote><p>有可能还有删除<code>Build Setting</code> -&gt; <code>Other Linker Flags</code>里的<code>-l&quot;stdc++.6.0.9&quot;</code></p></blockquote><p>但是现在部分第三方SDK依旧要依赖于<code>lstdc++.6.0.9.tbd</code>动态库，如果对代码进行改动或者修改 Xcode 的配置，可能会造成其他问题，例如在Xcode9.4上再次运行的时候可能会出现报错等等。</p><h3 id="方案二-1"><a href="#方案二-1" class="headerlink" title="方案二"></a>方案二</h3><p>最简单解决该问题的方法就是从 Xcode9.4 中找到动态库<code>lstdc++.6.0.9.tbd</code>、<code>libstdc++.6.tbd</code>、<code>libstdc++.tbd</code>文件复制到 Xcode10 下就可以完美解决问题。</p><ul><li><p>真机</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib/</span><br></pre></td></tr></table></figure></li><li><p>模拟器</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://pan.baidu.com/s/1T_TtQTh5Ff0bHM4Hcfj0tg" target="_blank" rel="noopener">libstdc++文件下载链接</a></p><h2 id="3-ld-symbol-s-not-found-for-architecture-x86-64"><a href="#3-ld-symbol-s-not-found-for-architecture-x86-64" class="headerlink" title="3. ld: symbol(s) not found for architecture x86_64"></a>3. ld: symbol(s) not found for architecture x86_64</h2><p>前面两个问题解决后，就遇到了这个问题，目前，在模拟器运行的时候会报这个错误，而使用真机运行的话没有问题，猜测应该是iOS12 模拟器的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">ld: warning: ignoring file /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator12.0.sdk/usr/lib/libstdc++.6.0.9.tbd, missing required architecture x86_64 in file /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator12.0.sdk/usr/lib/libstdc++.6.0.9.tbd (3 slices)</span><br><span class="line">ld: warning: ignoring file /Users/joy/Documents/1药网Git/fangkuaiyi_ios/FKY/Vendors/AipOcrSdk/IdcardQuality.framework/IdcardQuality, missing required architecture x86_64 in file /Users/joy/Documents/1药网Git/fangkuaiyi_ios/FKY/Vendors/AipOcrSdk/IdcardQuality.framework/IdcardQuality (3 slices)</span><br><span class="line"></span><br><span class="line">Undefined symbols for architecture x86_64:</span><br><span class="line">  &quot;std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::basic_string(char const*, std::allocator&lt;char&gt; const&amp;)&quot;, referenced from:</span><br><span class="line">      _baidu_framework::HandleBasemapMerge(_baidu_vi::CVString const&amp;, _baidu_vi::CVString const&amp;, _baidu_vi::CVString const&amp;, char const*) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">  &quot;std::string::assign(std::string const&amp;)&quot;, referenced from:</span><br><span class="line">      _baidu_framework::HandleBasemapMerge(_baidu_vi::CVString const&amp;, _baidu_vi::CVString const&amp;, _baidu_vi::CVString const&amp;, char const*) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">  &quot;std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;::open(char const*, std::_Ios_Openmode)&quot;, referenced from:</span><br><span class="line">      _baidu_framework::HandleBasemapMerge(_baidu_vi::CVString const&amp;, _baidu_vi::CVString const&amp;, _baidu_vi::CVString const&amp;, char const*) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">  &quot;std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;::close()&quot;, referenced from:</span><br><span class="line">      _baidu_framework::HandleBasemapMerge(_baidu_vi::CVString const&amp;, _baidu_vi::CVString const&amp;, _baidu_vi::CVString const&amp;, char const*) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">  &quot;std::string::_Rep::_S_empty_rep_storage&quot;, referenced from:</span><br><span class="line">      _baidu_framework::HandleBasemapMerge(_baidu_vi::CVString const&amp;, _baidu_vi::CVString const&amp;, _baidu_vi::CVString const&amp;, char const*) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">  &quot;std::ios_base::Init::~Init()&quot;, referenced from:</span><br><span class="line">      __GLOBAL__sub_I_BVMDOfflineMapMerge.cpp in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">  &quot;std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;::~basic_fstream()&quot;, referenced from:</span><br><span class="line">      _baidu_framework::HandleBasemapMerge(_baidu_vi::CVString const&amp;, _baidu_vi::CVString const&amp;, _baidu_vi::CVString const&amp;, char const*) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">  &quot;std::string::_Rep::_M_destroy(std::allocator&lt;char&gt; const&amp;)&quot;, referenced from:</span><br><span class="line">      _baidu_framework::HandleBasemapMerge(_baidu_vi::CVString const&amp;, _baidu_vi::CVString const&amp;, _baidu_vi::CVString const&amp;, char const*) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">  &quot;std::ostream::tellp()&quot;, referenced from:</span><br><span class="line">      _baidu_framework::MergeDataPart(std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, _baidu_framework::tagVectorMapFile&amp;, int) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">  &quot;std::ostream::write(char const*, long)&quot;, referenced from:</span><br><span class="line">      _baidu_framework::MergeNamePart(std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, int) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">      _baidu_framework::MergeIndexPart(std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">      _baidu_framework::MergeDataPart(std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, _baidu_framework::tagVectorMapFile&amp;, int) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">      _baidu_framework::HandleBasemapMerge(_baidu_vi::CVString const&amp;, _baidu_vi::CVString const&amp;, _baidu_vi::CVString const&amp;, char const*) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">  &quot;std::istream::seekg(long long, std::_Ios_Seekdir)&quot;, referenced from:</span><br><span class="line">      _baidu_framework::MergeIndexPart(std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">      _baidu_framework::MergeDataPart(std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, _baidu_framework::tagVectorMapFile&amp;, int) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">      _baidu_framework::CheckPatchMd5(std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">  &quot;std::ios_base::Init::Init()&quot;, referenced from:</span><br><span class="line">      __GLOBAL__sub_I_BVMDOfflineMapMerge.cpp in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">  &quot;std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;::basic_fstream()&quot;, referenced from:</span><br><span class="line">      _baidu_framework::HandleBasemapMerge(_baidu_vi::CVString const&amp;, _baidu_vi::CVString const&amp;, _baidu_vi::CVString const&amp;, char const*) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">  &quot;std::istream::tellg()&quot;, referenced from:</span><br><span class="line">      _baidu_framework::MergeNamePart(std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, int) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">      _baidu_framework::MergeIndexPart(std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">      _baidu_framework::MergeDataPart(std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, _baidu_framework::tagVectorMapFile&amp;, int) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">      _baidu_framework::CheckPatchMd5(std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">  &quot;std::__throw_length_error(char const*)&quot;, referenced from:</span><br><span class="line">      std::vector&lt;_baidu_vi::CVPtrRef&lt;_baidu_framework::CTextureData&gt;, std::allocator&lt;_baidu_vi::CVPtrRef&lt;_baidu_framework::CTextureData&gt; &gt; &gt;::_M_fill_insert(__gnu_cxx::__normal_iterator&lt;_baidu_vi::CVPtrRef&lt;_baidu_framework::CTextureData&gt;*, std::vector&lt;_baidu_vi::CVPtrRef&lt;_baidu_framework::CTextureData&gt;, std::allocator&lt;_baidu_vi::CVPtrRef&lt;_baidu_framework::CTextureData&gt; &gt; &gt; &gt;, unsigned long, _baidu_vi::CVPtrRef&lt;_baidu_framework::CTextureData&gt; const&amp;) in BaiduMapAPI_Map(TextureDataLoader.o)</span><br><span class="line">  &quot;std::istream::read(char*, long)&quot;, referenced from:</span><br><span class="line">      _baidu_framework::MergeNamePart(std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, int) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">      _baidu_framework::MergeIndexPart(std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">      _baidu_framework::MergeDataPart(std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, _baidu_framework::tagVectorMapFile&amp;, int) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">      _baidu_framework::CheckPatchMd5(std::basic_fstream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">      _baidu_framework::HandleBasemapMerge(_baidu_vi::CVString const&amp;, _baidu_vi::CVString const&amp;, _baidu_vi::CVString const&amp;, char const*) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">  &quot;std::basic_filebuf&lt;char, std::char_traits&lt;char&gt; &gt;::is_open() const&quot;, referenced from:</span><br><span class="line">      _baidu_framework::HandleBasemapMerge(_baidu_vi::CVString const&amp;, _baidu_vi::CVString const&amp;, _baidu_vi::CVString const&amp;, char const*) in BaiduMapAPI_Map(BVMDOfflineMapMerge.o)</span><br><span class="line">ld: symbol(s) not found for architecture x86_64</span><br><span class="line">clang: error: linker command failed with exit code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Multiple-commands-produce&quot;&gt;&lt;a href=&quot;#1-Multiple-commands-produce&quot; class=&quot;headerlink&quot; title=&quot;1. Multiple  commands produce&quot;&gt;&lt;/a&gt;1. 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mac下用Python写iOS自动化测试</title>
    <link href="https://fightingjoey.github.io/2018/10/10/%E6%95%99%E7%A8%8B/Mac%E4%B8%8B%E7%94%A8Python%E5%86%99iOS%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    <id>https://fightingjoey.github.io/2018/10/10/教程/Mac下用Python写iOS自动化测试/</id>
    <published>2018-10-10T06:45:56.000Z</published>
    <updated>2018-11-30T02:02:20.398Z</updated>
    
    <content type="html"><![CDATA[<p>安装环境：</p><ul><li>MacOS Mojave 10.14</li><li>Xcode10.1</li></ul><h2 id="安装libimobiledevice"><a href="#安装libimobiledevice" class="headerlink" title="安装libimobiledevice"></a>安装libimobiledevice</h2><h3 id="网上查到的教程"><a href="#网上查到的教程" class="headerlink" title="网上查到的教程"></a>网上查到的教程</h3><p>移除所有的 iOS 设备，然后在终端输入以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">brew uninstall ideviceinstaller</span><br><span class="line">brew uninstall libimobiledevice</span><br><span class="line">brew install --HEAD libimobiledevice</span><br><span class="line">brew link --overwrite libimobiledevice</span><br><span class="line">brew install --HEAD  ideviceinstaller</span><br><span class="line">brew link --overwrite ideviceinstaller</span><br><span class="line">sudo rm -rf /var/db/lockdown/*</span><br></pre></td></tr></table></figure><p>连接一台iOS设备，并信任，然后输入以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod -R 777 /var/db/lockdown/</span><br></pre></td></tr></table></figure><p>查看手机信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ideviceinfo -d</span><br></pre></td></tr></table></figure><p>查看手机上安装的所有APP的 BundleId</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ideviceinstaller -l</span><br></pre></td></tr></table></figure><h3 id="实际安装过程"><a href="#实际安装过程" class="headerlink" title="实际安装过程"></a>实际安装过程</h3><h4 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h4><p>在运行<code>brew install --HEAD libimobiledevice</code>这段代码时遇到问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Last 15 lines from /Users/joy/Library/Logs/Homebrew/libimobiledevice/01.autogen.sh:</span><br><span class="line">checking dynamic linker characteristics... darwin18.0.0 dyld</span><br><span class="line">checking how to hardcode library paths into programs... immediate</span><br><span class="line">checking for pkg-config... /usr/local/opt/pkg-config/bin/pkg-config</span><br><span class="line">checking pkg-config is at least version 0.9.0... yes</span><br><span class="line">checking for libusbmuxd &gt;= 1.1.0... no</span><br><span class="line">configure: error: Package requirements (libusbmuxd &gt;= 1.1.0) were not met:</span><br><span class="line"></span><br><span class="line">Requested &apos;libusbmuxd &gt;= 1.1.0&apos; but version of libusbmuxd is 1.0.10</span><br><span class="line"></span><br><span class="line">Consider adjusting the PKG_CONFIG_PATH environment variable if you</span><br><span class="line">installed software in a non-standard prefix.</span><br><span class="line"></span><br><span class="line">Alternatively, you may set the environment variables libusbmuxd_CFLAGS</span><br><span class="line">and libusbmuxd_LIBS to avoid the need to call pkg-config.</span><br><span class="line">See the pkg-config man page for more details.</span><br></pre></td></tr></table></figure><p>看上去是<code>libusbmuxd</code>的版本不对。在网上查了很多方案以后，发现只能编译安装1.1.0版本。</p><h4 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h4><p>编译安装的时候需要依赖于很多库，不过由于我一开始使用<code>brew install --HEAD libimobiledevice</code>的时候，自动给我安装好了依赖的库，所以就不需要我再一一编译安装了。</p><h5 id="编译安装libusbmuxd-1-1-0"><a href="#编译安装libusbmuxd-1-1-0" class="headerlink" title="编译安装libusbmuxd-1.1.0"></a>编译安装libusbmuxd-1.1.0</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/libimobiledevice/libusbmuxd.git</span><br><span class="line">cd libusbmuxd</span><br><span class="line">./autogen.sh</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h5 id="编译安装libimobiledevice"><a href="#编译安装libimobiledevice" class="headerlink" title="编译安装libimobiledevice"></a>编译安装libimobiledevice</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/libimobiledevice/libimobiledevice.git</span><br><span class="line">cd libimobiledevice</span><br><span class="line">./autogen.sh</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>在运行 <code>./autogen.sh</code> 又遇到问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">checking for openssl &gt;= 0.9.8... no</span><br><span class="line">configure: error: OpenSSL support explicitly requested but OpenSSL could not be found</span><br></pre></td></tr></table></figure><p>我确认我安装的<code>openssl</code>版本都是1.0以上，但还是报<code>openssl</code>版本错误。在网上查到，依赖库可以使用<code>openssl</code>或<code>GnuTLS</code>，所以我决定用另一个试一试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install GnuTLS</span><br></pre></td></tr></table></figure><p>安装完依赖库以后，输入以下代码重新编译安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./autogen.sh --disable-openssl</span><br></pre></td></tr></table></figure><p>又遇到一个新的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure: error: libgcrypt is required to build libimobiledevice with GnuTLS</span><br></pre></td></tr></table></figure><p>需要安装<code>libgcrypt</code>库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install libgcrypt</span><br></pre></td></tr></table></figure><p>安装完成后，重新编译安装，OK，No problem~</p><h5 id="编译安装ideveceinstaller"><a href="#编译安装ideveceinstaller" class="headerlink" title="编译安装ideveceinstaller"></a>编译安装ideveceinstaller</h5><p>我本来想用 HomeBrew 安装，结果发现在 HomeBrew 安装 ideveceinstaller 时，它依赖于libimobiledevice，会自动下载某个稳定版的 libimobiledevice ，所以最好还是只能编译安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/libimobiledevice/ideviceinstaller.git</span><br><span class="line">cd ideviceinstaller</span><br><span class="line">./autogen.sh</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><h3 id="安装WebDriverAgent"><a href="#安装WebDriverAgent" class="headerlink" title="安装WebDriverAgent"></a>安装WebDriverAgent</h3><h4 id="真机安装WebDriverAgent"><a href="#真机安装WebDriverAgent" class="headerlink" title="真机安装WebDriverAgent"></a>真机安装WebDriverAgent</h4><p><a href="https://testerhome.com/topics/7220" target="_blank" rel="noopener">ATX 文档 - iOS 真机如何安装 WebDriverAgent</a></p><p>从<code>GitHub</code>上下载代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/facebook/WebDriverAgent</span><br></pre></td></tr></table></figure><p>运行初始化脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Scripts/bootstrap.sh</span><br></pre></td></tr></table></figure><p>该脚本会使用<a href="https://github.com/Carthage/Carthage" target="_blank" rel="noopener">Carthage</a>下载所有的依赖，使用<code>npm</code>打包响应的js文件</p><p>执行完成后，直接双击打开<code>WebDriverAgent.xcodeproj</code>这个文件。</p><p>设置好<code>Team</code>、<code>Profile</code>、<code>Signing Certificate</code>以后，选择真机，<code>Product</code> -&gt; <code>Test</code>。</p><p>一切正常的话，手机上会出现一个无图标的<code>WebDriverAgent</code>应用，启动之后，马上又返回到桌面。这是很正常的不要奇怪。</p><p>此时控制台界面可以看到设备的IP。</p><p>通过上面给出的IP和端口，加上<code>/status</code>合成一个url地址。例如<code>http://10.0.0.1:8100/status</code>，然后浏览器打开。如果出现一串JSON输出，说明WDA安装成功了。</p><blockquote><p>而inspector的地址是<code>http://localhost:8100/inspector</code>， inspector 是用来查看UI的图层，方便写测试脚本用的</p></blockquote><h4 id="使用终端替代Xcode"><a href="#使用终端替代Xcode" class="headerlink" title="使用终端替代Xcode"></a>使用终端替代Xcode</h4><p>通常来说为了持续集成，能够全部自动化比较好一些</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 解锁keychain，以便可以正常的签名应用，</span><br><span class="line">PASSWORD=&quot;replace-with-your-password&quot;</span><br><span class="line">security unlock-keychain -p $PASSWORD ~/Library/Keychains/login.keychain</span><br><span class="line"></span><br><span class="line"># 获取设备的UDID</span><br><span class="line">UDID=$(idevice_id -l | head -n1)</span><br><span class="line"></span><br><span class="line"># 运行测试</span><br><span class="line">xcodebuild -project WebDriverAgent.xcodeproj -scheme WebDriverAgentRunner -destination &quot;id=$UDID&quot; test</span><br></pre></td></tr></table></figure><h4 id="安装Python3-wda"><a href="#安装Python3-wda" class="headerlink" title="安装Python3 wda"></a>安装Python3 wda</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --pre facebook-wda</span><br></pre></td></tr></table></figure><p>这个时候就可以来写python脚本了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import wda</span><br><span class="line"></span><br><span class="line">c = wda.Client(url=&apos;http://169.254.16.231:8100&apos;)</span><br><span class="line"></span><br><span class="line">index = 0</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 打开测试APP</span><br><span class="line">    with c.session(&apos;com.jifen.qukan&apos;) as s:</span><br><span class="line">        # 此时的s就是当前打开app的回话对象，我们可以通过它来操作app的内容</span><br><span class="line">        # 具体的语法可以在wda的README.md里面找到，这里就不说了</span><br><span class="line">if s(type=&apos;Button&apos;, name=u&apos;视频&apos;).exists:</span><br><span class="line">s(type=&apos;Button&apos;, name=u&apos;视频&apos;).tap()</span><br><span class="line"></span><br><span class="line">time.sleep(3)</span><br><span class="line"></span><br><span class="line">while(True):</span><br><span class="line">pushSubVC(s)</span><br><span class="line"></span><br><span class="line">def pushSubVC(s):</span><br><span class="line">global index</span><br><span class="line">es = s(label=&apos;home content ext&apos;).find_elements()</span><br><span class="line">i = 1</span><br><span class="line">for e in es:</span><br><span class="line">print(i)</span><br><span class="line">i+=1</span><br><span class="line">d = es[index]</span><br><span class="line">rect = d.bounds</span><br><span class="line">x = rect.x</span><br><span class="line">y = rect.y</span><br><span class="line">index=index+1</span><br><span class="line">s.click(x,y-20)</span><br><span class="line">time.sleep(63)</span><br><span class="line">if s(label=&apos;home content back white&apos;).exists:</span><br><span class="line">d = s(label=&apos;home content back white&apos;)</span><br><span class="line">d.tap()</span><br><span class="line">if s(type=&apos;ScrollView&apos;).exists:</span><br><span class="line">d = s(type=&apos;ScrollView&apos;)</span><br><span class="line">d.scroll(direction=&apos;down&apos;,distance=0.4)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><h3 id="安装libimobiledevice-1"><a href="#安装libimobiledevice-1" class="headerlink" title="安装libimobiledevice"></a>安装libimobiledevice</h3><p><a href="https://www.jianshu.com/p/2f3155593d2f" target="_blank" rel="noopener">获取手机已安装app的bundleid</a></p><p><a href="https://blog.csdn.net/kmkm3333/article/details/79008716" target="_blank" rel="noopener">安装和使用ideviceinstaller时遇到的坑</a></p><p><a href="https://www.jianshu.com/p/aff1773943fd" target="_blank" rel="noopener">libimobiledevice安装（Mac）</a></p><p><a href="https://www.jianshu.com/p/31de4b15b347" target="_blank" rel="noopener">编译安装libimobiledevice</a></p><h3 id="自动化测试-1"><a href="#自动化测试-1" class="headerlink" title="自动化测试"></a>自动化测试</h3><p><a href="https://blog.methodname.com/webdriveragenthe-wda/" target="_blank" rel="noopener">使用Python写iOS自动化测试</a></p><p><a href="https://blog.csdn.net/PRIMEFJT/article/details/78947480" target="_blank" rel="noopener">iOS WebDriverAgent 环境搭建</a></p><p><a href="https://blog.csdn.net/youxiansanren/article/details/49335385" target="_blank" rel="noopener">iOS+Python+Appium真机自动化测试实战</a></p><p><a href="https://blog.csdn.net/pengyuan_D/article/details/79932981" target="_blank" rel="noopener">Python + Appium+ IOS自动化测试</a></p><p><a href="https://www.jianshu.com/p/505525e2bb01" target="_blank" rel="noopener">MAC下搭建 appium+ios+python 自动化测试环境</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;安装环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MacOS Mojave 10.14&lt;/li&gt;
&lt;li&gt;Xcode10.1&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;安装libimobiledevice&quot;&gt;&lt;a href=&quot;#安装libimobiledevice&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="Mac" scheme="https://fightingjoey.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式验证</title>
    <link href="https://fightingjoey.github.io/2018/08/22/%E5%BC%80%E5%8F%91/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%AA%8C%E8%AF%81/"/>
    <id>https://fightingjoey.github.io/2018/08/22/开发/正则表达式验证/</id>
    <published>2018-08-22T03:33:23.000Z</published>
    <updated>2018-09-27T02:10:41.492Z</updated>
    
    <content type="html"><![CDATA[<h4 id="是否为电话号码【简单写法】"><a href="#是否为电话号码【简单写法】" class="headerlink" title="是否为电话号码【简单写法】"></a>是否为电话号码【简单写法】</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> *  是否为电话号码【简单写法】</span><br><span class="line"> *</span><br><span class="line"> *  @param pattern 传入需要检测的字符串</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回检测结果 是或者不是</span><br><span class="line"> */</span><br><span class="line">+(BOOL)GS_isPhoneNumber:(NSString *)phoneNum</span><br><span class="line">&#123;</span><br><span class="line">    NSString *MOBILE = @&quot;^1(3[0-9]|4[57]|5[0-35-9]|8[0-9]|70)\\d&#123;8&#125;$&quot;;</span><br><span class="line">    NSPredicate *regextestmobile = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, MOBILE];</span><br><span class="line">    return [regextestmobile evaluateWithObject:phoneNum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="是否为电话号码【复杂写法】"><a href="#是否为电话号码【复杂写法】" class="headerlink" title="是否为电话号码【复杂写法】"></a>是否为电话号码【复杂写法】</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> *  是否为电话号码【复杂写法】</span><br><span class="line"> *</span><br><span class="line"> *  @param pattern 传入需要检测的字符串</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回检测结果 是或者不是</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)GS_isMobileNumber:(NSString *)mobileNum</span><br><span class="line">&#123;</span><br><span class="line">    if (mobileNum.length != 11)</span><br><span class="line">    &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 手机号码:</span><br><span class="line">     * 13[0-9], 14[5,7], 15[0, 1, 2, 3, 5, 6, 7, 8, 9], 17[6, 7, 8], 18[0-9], 170[0-9]</span><br><span class="line">     * 移动号段: 134,135,136,137,138,139,150,151,152,157,158,159,182,183,184,187,188,147,178,1705</span><br><span class="line">     * 联通号段: 130,131,132,155,156,185,186,145,176,1709</span><br><span class="line">     * 电信号段: 133,153,180,181,189,177,1700</span><br><span class="line">     */</span><br><span class="line">    NSString *MOBILE = @&quot;^1(3[0-9]|4[57]|5[0-35-9]|8[0-9]|70)\\d&#123;8&#125;$&quot;;</span><br><span class="line">    /**</span><br><span class="line">     * 中国移动：China Mobile</span><br><span class="line">     * 134,135,136,137,138,139,150,151,152,157,158,159,182,183,184,187,188,147,178,1705</span><br><span class="line">     */</span><br><span class="line">    NSString *CM = @&quot;(^1(3[4-9]|4[7]|5[0-27-9]|7[8]|8[2-478])\\d&#123;8&#125;$)|(^1705\\d&#123;7&#125;$)&quot;;</span><br><span class="line">    /**</span><br><span class="line">     * 中国联通：China Unicom</span><br><span class="line">     * 130,131,132,155,156,185,186,145,176,1709</span><br><span class="line">     */</span><br><span class="line">    NSString *CU = @&quot;(^1(3[0-2]|4[5]|5[56]|7[6]|8[56])\\d&#123;8&#125;$)|(^1709\\d&#123;7&#125;$)&quot;;</span><br><span class="line">    /**</span><br><span class="line">     * 中国电信：China Telecom</span><br><span class="line">     * 133,153,180,181,189,177,1700</span><br><span class="line">     */</span><br><span class="line">    NSString *CT = @&quot;(^1(33|53|77|8[019])\\d&#123;8&#125;$)|(^1700\\d&#123;7&#125;$)&quot;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    NSPredicate *regextestmobile = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, MOBILE];</span><br><span class="line">    NSPredicate *regextestcm = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CM];</span><br><span class="line">    NSPredicate *regextestcu = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CU];</span><br><span class="line">    NSPredicate *regextestct = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CT];</span><br><span class="line">    </span><br><span class="line">    if (([regextestmobile evaluateWithObject:mobileNum] == YES)</span><br><span class="line">        || ([regextestcm evaluateWithObject:mobileNum] == YES)</span><br><span class="line">        || ([regextestct evaluateWithObject:mobileNum] == YES)</span><br><span class="line">        || ([regextestcu evaluateWithObject:mobileNum] == YES))</span><br><span class="line">    &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">//    </span><br><span class="line">//    //验证方法2</span><br><span class="line">//    /**</span><br><span class="line">//     * 手机号码</span><br><span class="line">//     * 移动：134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188</span><br><span class="line">//     * 联通：130,131,132,152,155,156,185,186</span><br><span class="line">//     * 电信：133,1349,153,180,189</span><br><span class="line">//     */</span><br><span class="line">//    //    NSString * MOBILE = @&quot;^1(3[0-9]|5[0-35-9]|8[025-9])\\d&#123;8&#125;$&quot;;</span><br><span class="line">//    </span><br><span class="line">//    </span><br><span class="line">//    /**</span><br><span class="line">//     * 中国移动：China Mobile</span><br><span class="line">//     * 134[0-8],135,136,137,138,139,150,151,157,158,159,182,187,188</span><br><span class="line">//     */</span><br><span class="line">//    //    NSString * CM = @&quot;^1(34[0-8]|(3[5-9]|5[017-9]|8[278])\\d)\\d&#123;7&#125;$&quot;; // China Mobile phoneNum</span><br><span class="line">//    </span><br><span class="line">//    /**</span><br><span class="line">//     * 中国联通：China Unicom</span><br><span class="line">//     * 130,131,132,152,155,156,185,186</span><br><span class="line">//     */</span><br><span class="line">//    //    NSString * CU = @&quot;^1(3[0-2]|5[256]|8[56])\\d&#123;8&#125;$&quot;; // China Unicom phoneNum</span><br><span class="line">//    </span><br><span class="line">//    </span><br><span class="line">//    /**</span><br><span class="line">//     * 中国电信：China Telecom</span><br><span class="line">//     * 133,1349,153,180,189</span><br><span class="line">//     */</span><br><span class="line">//    //    NSString * CT = @&quot;^1((33|53|8[09])[0-9]|349)\\d&#123;7&#125;$&quot;; // China Telecom phoneNum</span><br><span class="line">//    </span><br><span class="line">//    /**</span><br><span class="line">//     *  The following 4 predicate can tell which carrier the number is from.</span><br><span class="line">//     */</span><br><span class="line">//    //    NSPredicate *regextestmobile = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, MOBILE];</span><br><span class="line">//    //    NSPredicate *regextestcm = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CM];</span><br><span class="line">//    //    NSPredicate *regextestcu = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CU];</span><br><span class="line">//    //    NSPredicate *regextestct = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CT];</span><br><span class="line">//    </span><br><span class="line">//    </span><br><span class="line">//    //Only Check if the string is a valid telephone number, ignoring the carrier info.</span><br><span class="line">//    </span><br><span class="line">//    NSString *isMobileRegex = @&quot;^(((13[0-9]&#123;1&#125;)|(15[0-9]&#123;1&#125;)|(17[0-9]&#123;1&#125;)|(18[0,5-9]&#123;1&#125;))+\\d&#123;8&#125;)$&quot;;</span><br><span class="line">//    </span><br><span class="line">//    </span><br><span class="line">//    //    NSString *isMobileRegex = @&quot;^((\\+86)|(\\(\\+86\\)))?(((13[0-9]&#123;1&#125;)|(15[0-9]&#123;1&#125;)|(17[0-9]&#123;1&#125;)|(18[0,5-9]&#123;1&#125;))+\\d&#123;8&#125;)$&quot;;</span><br><span class="line">//    </span><br><span class="line">//    </span><br><span class="line">//    NSPredicate *mobileRegex = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, isMobileRegex];</span><br><span class="line">//    </span><br><span class="line">//    if (([mobileRegex evaluateWithObject:telephoneNum] == YES))</span><br><span class="line">//    &#123;</span><br><span class="line">//        return YES;</span><br><span class="line">//        </span><br><span class="line">//    &#125;else&#123;</span><br><span class="line">//        return NO;</span><br><span class="line">//    &#125;</span><br><span class="line">//    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断是否是：移动手机号"><a href="#判断是否是：移动手机号" class="headerlink" title="判断是否是：移动手机号"></a>判断是否是：移动手机号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> *  判断是否是：移动手机号</span><br><span class="line"> *</span><br><span class="line"> *  @param phoneNum 手机号码</span><br><span class="line"> *</span><br><span class="line"> *  @return 移动手机号</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)GS_isChinaMobile:(NSString *)phoneNum</span><br><span class="line">&#123;</span><br><span class="line">    /*!</span><br><span class="line">     * 中国移动：China Mobile</span><br><span class="line">     * 134,135,136,137,138,139,150,151,152,157,158,159,182,183,184,187,188,147,178,1705</span><br><span class="line">     */</span><br><span class="line">    NSString *CM = @&quot;(^1(3[4-9]|4[7]|5[0-27-9]|7[8]|8[2-478])\\d&#123;8&#125;$)|(^1705\\d&#123;7&#125;$)&quot;;</span><br><span class="line">    NSPredicate *regextestcm = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CM];</span><br><span class="line">    return [regextestcm evaluateWithObject:phoneNum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断是否是：联通手机号"><a href="#判断是否是：联通手机号" class="headerlink" title="判断是否是：联通手机号"></a>判断是否是：联通手机号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> *  判断是否是：联通手机号</span><br><span class="line"> *</span><br><span class="line"> *  @param phoneNum 手机号码</span><br><span class="line"> *</span><br><span class="line"> *  @return 联通手机号</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)GS_isChinaUnicom:(NSString *)phoneNum</span><br><span class="line">&#123;</span><br><span class="line">    /*!</span><br><span class="line">     * 中国联通：China Unicom</span><br><span class="line">     * 130,131,132,155,156,185,186,145,176,1709</span><br><span class="line">     */</span><br><span class="line">    NSString *CU = @&quot;(^1(3[0-2]|4[5]|5[56]|7[6]|8[56])\\d&#123;8&#125;$)|(^1709\\d&#123;7&#125;$)&quot;;</span><br><span class="line">    NSPredicate *regextestcm = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CU];</span><br><span class="line">    return [regextestcm evaluateWithObject:phoneNum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断是否是：电信手机号"><a href="#判断是否是：电信手机号" class="headerlink" title="判断是否是：电信手机号"></a>判断是否是：电信手机号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> *  判断是否是：电信手机号</span><br><span class="line"> *</span><br><span class="line"> *  @param phoneNum 手机号码</span><br><span class="line"> *</span><br><span class="line"> *  @return 电信手机号</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)GS_isChinaTelecom:(NSString *)phoneNum</span><br><span class="line">&#123;</span><br><span class="line">    /*!</span><br><span class="line">     * 中国电信：China Telecom</span><br><span class="line">     * 133,153,180,181,189,177,1700</span><br><span class="line">     */</span><br><span class="line">    NSString *CT = @&quot;^1((33|53|8[019])[0-9]|349)\\d&#123;7&#125;$&quot;;</span><br><span class="line">    NSPredicate *regextestcm = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, CT];</span><br><span class="line">    return [regextestcm evaluateWithObject:phoneNum];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断具体是哪个运营商的手机号"><a href="#判断具体是哪个运营商的手机号" class="headerlink" title="判断具体是哪个运营商的手机号"></a>判断具体是哪个运营商的手机号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> *  判断具体是哪个运营商的手机号</span><br><span class="line"> *</span><br><span class="line"> *  @param phoneNum 传入需要检测的字符串</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回：中国移动、中国联通、中国电信、未知</span><br><span class="line"> */</span><br><span class="line">+ (NSString *)GS_getPhoneNumType:(NSString *)phoneNum</span><br><span class="line">&#123;</span><br><span class="line">    return [GSRegularExpression GS_isChinaMobile:phoneNum]? @&quot;中国移动&quot;: ([GSRegularExpression GS_isChinaUnicom:phoneNum]? @&quot;中国联通&quot;:([GSRegularExpression GS_isChinaTelecom:phoneNum]? @&quot;中国电信&quot;: @&quot;未知号码&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="检测是否为邮箱"><a href="#检测是否为邮箱" class="headerlink" title="检测是否为邮箱"></a>检测是否为邮箱</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> *  检测是否为邮箱</span><br><span class="line"> *</span><br><span class="line"> *  @param pattern 传入需要检测的字符串</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回检测结果 是或者不是</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)GS_isEmailQualified:(NSString *)emailStr</span><br><span class="line">&#123;</span><br><span class="line">    NSString *pattern = @&quot;[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]&#123;2,4&#125;&quot;;</span><br><span class="line">    NSRegularExpression *regex = [[NSRegularExpression alloc] initWithPattern:pattern options:0 error:nil];</span><br><span class="line">    NSArray *results = [regex matchesInString:emailStr options:0 range:NSMakeRange(0, emailStr.length)];</span><br><span class="line">    return results.count &gt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="检测用户输入密码是否以字母开头，长度在6-18之间，只能包含字符、数字和下划线。"><a href="#检测用户输入密码是否以字母开头，长度在6-18之间，只能包含字符、数字和下划线。" class="headerlink" title="检测用户输入密码是否以字母开头，长度在6-18之间，只能包含字符、数字和下划线。"></a>检测用户输入密码是否以字母开头，长度在6-18之间，只能包含字符、数字和下划线。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> *  检测用户输入密码是否以字母开头，长度在6-18之间，只能包含字符、数字和下划线。</span><br><span class="line"> *</span><br><span class="line"> *  @param pattern 传入需要检测的字符串</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回检测结果 是或者不是</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)GS_isPasswordQualified:(NSString *)passwordStr</span><br><span class="line">&#123;</span><br><span class="line">    //    NSString *pattern = @&quot;^[a-zA-Z]\\w.&#123;5,17&#125;$&quot;;</span><br><span class="line">    //    NSRegularExpression *regex = [[NSRegularExpression alloc] initWithPattern:pattern options:0 error:nil];</span><br><span class="line">    //    NSArray *results = [regex matchesInString:passwordStr options:0 range:NSMakeRange(0, passwordStr.length)];</span><br><span class="line">    //    return results.count &gt; 0;</span><br><span class="line">    </span><br><span class="line">    NSString *passWordRegex = @&quot;^[a-zA-Z]\\w.&#123;5,17&#125;$&quot;;</span><br><span class="line">    NSPredicate *passWordPredicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,passWordRegex];</span><br><span class="line">    return [passWordPredicate evaluateWithObject:passwordStr];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="验证身份证号（15位或18位数字）【最全的身份证校验，带校验位】"><a href="#验证身份证号（15位或18位数字）【最全的身份证校验，带校验位】" class="headerlink" title="验证身份证号（15位或18位数字）【最全的身份证校验，带校验位】"></a>验证身份证号（15位或18位数字）【最全的身份证校验，带校验位】</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *  验证身份证号（15位或18位数字）【最全的身份证校验，带校验位】</span><br><span class="line"> *  @param pattern 传入需要检测的字符串</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回检测结果 是或者不是</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)GS_isIdCardNumberQualified:(NSString *)idCardNumberStr</span><br><span class="line">&#123;</span><br><span class="line">    //    NSString *pattern = @&quot;^\\d&#123;15&#125;|\\d&#123;18&#125;$&quot;;</span><br><span class="line">    //    NSRegularExpression *regex = [[NSRegularExpression alloc] initWithPattern:pattern options:0 error:nil];</span><br><span class="line">    //    NSArray *results = [regex matchesInString:idCardNumberStr options:0 range:NSMakeRange(0, idCardNumberStr.length)];</span><br><span class="line">    //    return results.count &gt; 0;</span><br><span class="line">    </span><br><span class="line">    idCardNumberStr = [idCardNumberStr stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];</span><br><span class="line">    NSInteger length = 0;</span><br><span class="line">    if (!idCardNumberStr)</span><br><span class="line">    &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        length = idCardNumberStr.length;</span><br><span class="line">        if (length != 15 &amp;&amp; length !=18)</span><br><span class="line">        &#123;</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /*! 省份代码 */</span><br><span class="line">    NSArray *areasArray =@[@&quot;11&quot;, @&quot;12&quot;, @&quot;13&quot;, @&quot;14&quot;, @&quot;15&quot;, @&quot;21&quot;, @&quot;22&quot;, @&quot;23&quot;, @&quot;31&quot;, @&quot;32&quot;, @&quot;33&quot;, @&quot;34&quot;, @&quot;35&quot;, @&quot;36&quot;, @&quot;37&quot;, @&quot;41&quot;, @&quot;42&quot;, @&quot;43&quot;, @&quot;44&quot;, @&quot;45&quot;, @&quot;46&quot;, @&quot;50&quot;, @&quot;51&quot;, @&quot;52&quot;, @&quot;53&quot;, @&quot;54&quot;, @&quot;61&quot;, @&quot;62&quot;, @&quot;63&quot;, @&quot;64&quot;, @&quot;65&quot;, @&quot;71&quot;, @&quot;81&quot;, @&quot;82&quot;, @&quot;91&quot;];</span><br><span class="line">    </span><br><span class="line">    NSString *valueStart2 = [idCardNumberStr substringToIndex:2];</span><br><span class="line">    BOOL areaFlag = NO;</span><br><span class="line">    for (NSString *areaCode in areasArray)</span><br><span class="line">    &#123;</span><br><span class="line">        if ([areaCode isEqualToString:valueStart2])</span><br><span class="line">        &#123;</span><br><span class="line">            areaFlag =YES;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!areaFlag)</span><br><span class="line">    &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSRegularExpression *regularExpression;</span><br><span class="line">    NSUInteger numberofMatch;</span><br><span class="line">    </span><br><span class="line">    NSInteger year = 0;</span><br><span class="line">    switch (length)</span><br><span class="line">    &#123;</span><br><span class="line">        case 15:</span><br><span class="line">            year = [idCardNumberStr substringWithRange:NSMakeRange(6,2)].intValue +1900;</span><br><span class="line">            </span><br><span class="line">            if (year % 4 ==0 || (year % 100 ==0 &amp;&amp; year % 4 ==0))</span><br><span class="line">            &#123;</span><br><span class="line">                /*! 测试出生日期的合法性 */</span><br><span class="line">                regularExpression = [[NSRegularExpression alloc] initWithPattern:@&quot;^[1-9][0-9]&#123;5&#125;[0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))[0-9]&#123;3&#125;$&quot;</span><br><span class="line">                                                                         options:NSRegularExpressionCaseInsensitive</span><br><span class="line">                                                                           error:nil];</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                /*! 测试出生日期的合法性 */</span><br><span class="line">                regularExpression = [[NSRegularExpression alloc] initWithPattern:@&quot;^[1-9][0-9]&#123;5&#125;[0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|1[0-9]|2[0-8]))[0-9]&#123;3&#125;$&quot;</span><br><span class="line">                                                                         options:NSRegularExpressionCaseInsensitive</span><br><span class="line">                                                                           error:nil];</span><br><span class="line">            &#125;</span><br><span class="line">            numberofMatch = [regularExpression numberOfMatchesInString:idCardNumberStr</span><br><span class="line">                                                               options:NSMatchingReportProgress</span><br><span class="line">                                                                 range:NSMakeRange(0, idCardNumberStr.length)];</span><br><span class="line">            </span><br><span class="line">            if(numberofMatch &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                return YES;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                return NO;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 18:</span><br><span class="line">            </span><br><span class="line">            year = [idCardNumberStr substringWithRange:NSMakeRange(6,4)].intValue;</span><br><span class="line">            if (year % 4 ==0 || (year % 100 ==0 &amp;&amp; year % 4 ==0))</span><br><span class="line">            &#123;</span><br><span class="line">                /*! 测试出生日期的合法性 */</span><br><span class="line">                regularExpression = [[NSRegularExpression alloc] initWithPattern:@&quot;^[1-9][0-9]&#123;5&#125;19[0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|[1-2][0-9]))[0-9]&#123;3&#125;[0-9Xx]$&quot;</span><br><span class="line">                                                                         options:NSRegularExpressionCaseInsensitive</span><br><span class="line">                                                                           error:nil];</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                /*! 测试出生日期的合法性 */</span><br><span class="line">                regularExpression = [[NSRegularExpression alloc] initWithPattern:@&quot;^[1-9][0-9]&#123;5&#125;19[0-9]&#123;2&#125;((01|03|05|07|08|10|12)(0[1-9]|[1-2][0-9]|3[0-1])|(04|06|09|11)(0[1-9]|[1-2][0-9]|30)|02(0[1-9]|1[0-9]|2[0-8]))[0-9]&#123;3&#125;[0-9Xx]$&quot;</span><br><span class="line">                                                                         options:NSRegularExpressionCaseInsensitive</span><br><span class="line">                                                                           error:nil];</span><br><span class="line">            &#125;</span><br><span class="line">            numberofMatch = [regularExpression numberOfMatchesInString:idCardNumberStr</span><br><span class="line">                                                               options:NSMatchingReportProgress</span><br><span class="line">                                                                 range:NSMakeRange(0, idCardNumberStr.length)];</span><br><span class="line">            </span><br><span class="line">            if(numberofMatch &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                NSInteger S = ([idCardNumberStr substringWithRange:NSMakeRange(0,1)].intValue + [idCardNumberStr substringWithRange:NSMakeRange(10,1)].intValue) *7 + ([idCardNumberStr substringWithRange:NSMakeRange(1,1)].intValue + [idCardNumberStr substringWithRange:NSMakeRange(11,1)].intValue) *9 + ([idCardNumberStr substringWithRange:NSMakeRange(2,1)].intValue + [idCardNumberStr substringWithRange:NSMakeRange(12,1)].intValue) *10 + ([idCardNumberStr substringWithRange:NSMakeRange(3,1)].intValue + [idCardNumberStr substringWithRange:NSMakeRange(13,1)].intValue) *5 + ([idCardNumberStr substringWithRange:NSMakeRange(4,1)].intValue + [idCardNumberStr substringWithRange:NSMakeRange(14,1)].intValue) *8 + ([idCardNumberStr substringWithRange:NSMakeRange(5,1)].intValue + [idCardNumberStr substringWithRange:NSMakeRange(15,1)].intValue) *4 + ([idCardNumberStr substringWithRange:NSMakeRange(6,1)].intValue + [idCardNumberStr substringWithRange:NSMakeRange(16,1)].intValue) *2 + [idCardNumberStr substringWithRange:NSMakeRange(7,1)].intValue *1 + [idCardNumberStr substringWithRange:NSMakeRange(8,1)].intValue *6 + [idCardNumberStr substringWithRange:NSMakeRange(9,1)].intValue *3;</span><br><span class="line">                NSInteger Y = S % 11;</span><br><span class="line">                NSString *M = @&quot;F&quot;;</span><br><span class="line">                NSString *JYM = @&quot;10X98765432&quot;;</span><br><span class="line">                /*! 判断校验位 */</span><br><span class="line">                M = [JYM substringWithRange:NSMakeRange(Y,1)];</span><br><span class="line">                if ([M isEqualToString:[idCardNumberStr substringWithRange:NSMakeRange(17,1)]])</span><br><span class="line">                &#123;</span><br><span class="line">                    /*! 检测ID的校验位 */</span><br><span class="line">                    return YES;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    return NO;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                return NO;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            return NO;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="验证IP地址（15位或18位数字）"><a href="#验证IP地址（15位或18位数字）" class="headerlink" title="验证IP地址（15位或18位数字）"></a>验证IP地址（15位或18位数字）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> *  验证IP地址（15位或18位数字）</span><br><span class="line"> *  @param pattern 传入需要检测的字符串</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回检测结果 是或者不是</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)GS_isIPAddress:(NSString *)iPAddressStr</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    NSString *pattern = @&quot;((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)&quot;;</span><br><span class="line">    NSRegularExpression *regex = [[NSRegularExpression alloc] initWithPattern:pattern options:0 error:nil];</span><br><span class="line">    NSArray *results = [regex matchesInString:iPAddressStr options:0 range:NSMakeRange(0, iPAddressStr.length)];</span><br><span class="line">    return results.count &gt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="验证输入的是否全为数字"><a href="#验证输入的是否全为数字" class="headerlink" title="验证输入的是否全为数字"></a>验证输入的是否全为数字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> *  验证输入的是否全为数字</span><br><span class="line"> *  @param pattern 传入需要检测的字符串</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回检测结果 是或者不是</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)GS_isAllNumber:(NSString *)allNumberStr</span><br><span class="line">&#123;</span><br><span class="line">    NSString *pattern = @&quot;^[0-9]*$&quot;;</span><br><span class="line">    NSRegularExpression *regex = [[NSRegularExpression alloc] initWithPattern:pattern options:0 error:nil];</span><br><span class="line">    NSArray *results = [regex matchesInString:allNumberStr options:0 range:NSMakeRange(0, allNumberStr.length)];</span><br><span class="line">    return results.count &gt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="验证由26个英文字母组成的字符串"><a href="#验证由26个英文字母组成的字符串" class="headerlink" title="验证由26个英文字母组成的字符串"></a>验证由26个英文字母组成的字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> *  验证由26个英文字母组成的字符串</span><br><span class="line"> *  @param pattern 传入需要检测的字符串</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回检测结果 是或者不是</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)GS_isEnglishAlphabet:(NSString *)englishAlphabetStr</span><br><span class="line">&#123;</span><br><span class="line">    NSString *pattern = @&quot;^[A-Za-z]+$&quot;;</span><br><span class="line">    NSRegularExpression *regex = [[NSRegularExpression alloc] initWithPattern:pattern options:0 error:nil];</span><br><span class="line">    NSArray *results = [regex matchesInString:englishAlphabetStr options:0 range:NSMakeRange(0, englishAlphabetStr.length)];</span><br><span class="line">    return results.count &gt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="验证输入的是否是URL地址"><a href="#验证输入的是否是URL地址" class="headerlink" title="验证输入的是否是URL地址"></a>验证输入的是否是URL地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> *  验证输入的是否是URL地址</span><br><span class="line"> *  @param pattern 传入需要检测的字符串</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回检测结果 是或者不是</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)GS_isUrl:(NSString *)urlStr</span><br><span class="line">&#123;</span><br><span class="line">    //    NSString* verifyRules=@&quot;^http://([\\w-]+\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$&quot;;</span><br><span class="line">    //    NSPredicate *verifyRulesPre = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,verifyRules];</span><br><span class="line">    //    return [verifyRulesPre evaluateWithObject:urlStr];</span><br><span class="line">    </span><br><span class="line">    NSString *pattern = @&quot;\\b(([\\w-]+://?|www[.])[^\\s()&lt;&gt;]+(?:\\([\\w\\d]+\\)|([^[:punct:]\\s]|/)))&quot;;</span><br><span class="line">    NSRegularExpression *regex = [[NSRegularExpression alloc] initWithPattern:pattern options:0 error:nil];</span><br><span class="line">    NSArray *results = [regex matchesInString:urlStr options:0 range:NSMakeRange(0, urlStr.length)];</span><br><span class="line">    return results.count &gt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="验证输入的是否是中文"><a href="#验证输入的是否是中文" class="headerlink" title="验证输入的是否是中文"></a>验证输入的是否是中文</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> *  验证输入的是否是中文</span><br><span class="line"> *  @param pattern 传入需要检测的字符串</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回检测结果 是或者不是</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)GS_isChinese:(NSString *)chineseStr</span><br><span class="line">&#123;</span><br><span class="line">    NSString *pattern = @&quot;[\u4e00-\u9fa5]+&quot;;</span><br><span class="line">    NSRegularExpression *regex = [[NSRegularExpression alloc] initWithPattern:pattern options:0 error:nil];</span><br><span class="line">    NSArray *results = [regex matchesInString:chineseStr options:0 range:NSMakeRange(0, chineseStr.length)];</span><br><span class="line">    return results.count &gt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="验证输入的是否是高亮显示"><a href="#验证输入的是否是高亮显示" class="headerlink" title="验证输入的是否是高亮显示"></a>验证输入的是否是高亮显示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> *  验证输入的是否是高亮显示</span><br><span class="line"> *  @param pattern 传入需要检测的字符串</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回检测结果 是或者不是</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)GS_isNormalText:(NSString *)normalStr WithHighLightText:(NSString *)HighLightStr</span><br><span class="line">&#123;</span><br><span class="line">    NSString *pattern = [NSString stringWithFormat:@&quot;%@&quot;,HighLightStr];</span><br><span class="line">    NSRegularExpression *regex = [[NSRegularExpression alloc] initWithPattern:pattern options:0 error:nil];</span><br><span class="line">    NSArray *results = [regex matchesInString:normalStr options:0 range:NSMakeRange(0, normalStr.length)];</span><br><span class="line">    for (NSTextCheckingResult *resltText in results) &#123;</span><br><span class="line">        NSLog(@&quot;----------------%zd&quot;,resltText.range.length);</span><br><span class="line">    &#125;</span><br><span class="line">    return results.count &gt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="车牌号验证"><a href="#车牌号验证" class="headerlink" title="车牌号验证"></a>车牌号验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> *  车牌号验证</span><br><span class="line"> *</span><br><span class="line"> *  @param carNumber carNumber</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回检测结果 是或者不是</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)GS_isValidateCarNumber:(NSString *)carNumber</span><br><span class="line">&#123;</span><br><span class="line">    NSString *carRegex = @&quot;^[\u4e00-\u9fa5]&#123;1&#125;[a-zA-Z]&#123;1&#125;[a-zA-Z_0-9]&#123;4&#125;[a-zA-Z_0-9_\u4e00-\u9fa5]$&quot;;</span><br><span class="line">    NSPredicate *catTest = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, carRegex];</span><br><span class="line">    return [catTest evaluateWithObject:carNumber];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="车型验证"><a href="#车型验证" class="headerlink" title="车型验证"></a>车型验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> *  车型验证</span><br><span class="line"> *</span><br><span class="line"> *  @param CarType CarType</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回检测结果 是或者不是</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)GS_isValidateCarType:(NSString *)CarType</span><br><span class="line">&#123;</span><br><span class="line">    NSString *CarTypeRegex = @&quot;^[\u4E00-\u9FFF]+$&quot;;</span><br><span class="line">    NSPredicate *carTest = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,CarTypeRegex];</span><br><span class="line">    return [carTest evaluateWithObject:CarType];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="昵称验证"><a href="#昵称验证" class="headerlink" title="昵称验证"></a>昵称验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line"> *  昵称验证</span><br><span class="line"> *</span><br><span class="line"> *  @param nickname nickname</span><br><span class="line"> *</span><br><span class="line"> *  @return 返回检测结果 是或者不是</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)GS_isValidateNickname:(NSString *)nickname</span><br><span class="line">&#123;</span><br><span class="line">    NSString *nicknameRegex = @&quot;^[\u4e00-\u9fa5]&#123;4,8&#125;$&quot;;</span><br><span class="line">    NSPredicate *passWordPredicate = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;,nicknameRegex];</span><br><span class="line">    return [passWordPredicate evaluateWithObject:nickname];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;是否为电话号码【简单写法】&quot;&gt;&lt;a href=&quot;#是否为电话号码【简单写法】&quot; class=&quot;headerlink&quot; title=&quot;是否为电话号码【简单写法】&quot;&gt;&lt;/a&gt;是否为电话号码【简单写法】&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/*!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  是否为电话号码【简单写法】&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  @param pattern 传入需要检测的字符串&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *  @return 返回检测结果 是或者不是&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+(BOOL)GS_isPhoneNumber:(NSString *)phoneNum&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSString *MOBILE = @&amp;quot;^1(3[0-9]|4[57]|5[0-35-9]|8[0-9]|70)\\d&amp;#123;8&amp;#125;$&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSPredicate *regextestmobile = [NSPredicate predicateWithFormat:@&amp;quot;SELF MATCHES %@&amp;quot;, MOBILE];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return [regextestmobile evaluateWithObject:phoneNum];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="开发" scheme="https://fightingjoey.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>OC优秀的第三方库</title>
    <link href="https://fightingjoey.github.io/2018/07/28/%E5%BC%80%E5%8F%91/OC%E4%BC%98%E7%A7%80%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    <id>https://fightingjoey.github.io/2018/07/28/开发/OC优秀的第三方库/</id>
    <published>2018-07-28T07:30:59.000Z</published>
    <updated>2018-09-27T02:09:57.017Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0C优秀的第三方库"><a href="#0C优秀的第三方库" class="headerlink" title="0C优秀的第三方库"></a>0C优秀的第三方库</h3><h4 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h4><ul><li><p><a href="https://github.com/xueyongwei/XYWSoundChanger" target="_blank" rel="noopener">XYWSoundChanger</a> - iOS视频变声器，对录制或下载的视频进行变声，对视频原声处理成大叔、萝莉、搞怪等效果</p></li><li><p><a href="https://github.com/ChangbaDevs/KTVVideoProcess" target="_blank" rel="noopener">KTVVideoProcess</a> - 来自Changba iOS团队的高性能视频效果处理框架</p></li><li><p><a href="https://github.com/yasginiwa/YGPlayer" target="_blank" rel="noopener">YGPlayer</a> - iOS video player.（iOS播放器）</p></li><li><p><a href="https://github.com/36Kr-Mobile/KRVideoPlayer" target="_blank" rel="noopener">KRVideoPlayer</a> - 36氪开源的视频播放器</p></li></ul><h4 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h4><ul><li><a href="https://github.com/douban/DOUAudioStreamer" target="_blank" rel="noopener">DOUAudioStreamer</a> - 豆瓣开源的音频播放器</li></ul><h4 id="AR"><a href="#AR" class="headerlink" title="AR"></a>AR</h4><ul><li><p><a href="https://github.com/SherlockQi/HeavenMemoirs" target="_blank" rel="noopener">HeavenMemoirs</a> - AR相册</p></li><li><p><a href="https://github.com/ProjectDent/ARKit-CoreLocation" target="_blank" rel="noopener">ARKit-CoreLocation</a> - 将AR的高精度与GPS数据的比例结合起来</p></li></ul><a id="more"></a><h4 id="侧滑"><a href="#侧滑" class="headerlink" title="侧滑"></a>侧滑</h4><ul><li><p><a href="https://github.com/choiceyou/FWSideMenu" target="_blank" rel="noopener">FWSideMenu</a> - iOS侧滑控件，支持左、右滑动的侧滑菜单，可配置单侧滑动，同时可配置菜单宽度等</p></li><li><p><a href="https://github.com/pkluz/PKRevealController" target="_blank" rel="noopener">PKRevealController</a> - PKRevealController是一个可滑动的侧边栏（向左、向右或者都可以）</p></li></ul><h4 id="Tabbar"><a href="#Tabbar" class="headerlink" title="Tabbar"></a>Tabbar</h4><ul><li><a href="https://github.com/axclogo/AxcAE_TabBar" target="_blank" rel="noopener">AxcAE_TabBar</a> - 特效TabBar，以开放为封装核心的TabBar组件，尽量将属性、API等参数全部开放给使用者</li></ul><h4 id="Banner"><a href="#Banner" class="headerlink" title="Banner"></a>Banner</h4><ul><li><a href="https://github.com/daimengxiaozhi/MDShockBannerView" target="_blank" rel="noopener">MDShockBannerView</a> - 仿转转首页banner</li></ul><h4 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h4><ul><li><a href="https://github.com/robbiehanson/CocoaAsyncSocket" target="_blank" rel="noopener">CocoaAsyncSocket</a>- 封装最完善的Socket类库</li></ul><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><ul><li><a href="https://github.com/HDB-Li/LLDebugTool" target="_blank" rel="noopener">LLDebugTool</a> - 便捷的IOS调试工具(新增截屏功能)</li></ul><h4 id="开源APP"><a href="#开源APP" class="headerlink" title="开源APP"></a>开源APP</h4><h5 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h5><ol><li><p><a href="https://github.com/xumaohuai/MONO" target="_blank" rel="noopener">高仿MONO(猫弄)</a></p></li><li><p><a href="https://github.com/imjog/phimpme-iOS" target="_blank" rel="noopener">Phimp.me</a> - 是iOS的照片应用程序，旨在取代专有照片应用程序。 它提供了诸如拍照，添加过滤器，编辑图像并将其上传到社交网络等功能</p></li><li><p><a href="https://github.com/Coding/CodingMart_iOS" target="_blank" rel="noopener">码市 iOS 客户端源代码</a></p></li><li><p><a href="http://www.wangquanwei.com/2018-03-13-1.html" target="_blank" rel="noopener">gank.io客户端</a></p></li></ol><h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><ol><li><a href="https://github.com/SamuelGjk/MpGank" target="_blank" rel="noopener">Gank.io 微信小程序</a></li></ol><h5 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h5><ol><li><a href="https://github.com/pluosi/app-host" target="_blank" rel="noopener">开源一个 APP 内网发布系统（OTA）</a></li></ol><h4 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h4><ol><li><p><a href="https://allmachinelearning.github.io/MachineLearning/" target="_blank" rel="noopener">机器学习资源</a></p></li><li><p><a href="https://github.com/edvardHua/PoseEstimationForMobile" target="_blank" rel="noopener">智能手机（Android和IOS）的单人姿势检测</a></p></li><li><p><a href="https://github.com/yuxitong/TensorFlowAndroidDemo" target="_blank" rel="noopener">TensorFlow android demo 车道线 车辆 人脸 动作 骨架 识别 检测</a></p></li><li><p><a href="https://github.com/ardamavi/Vocalization-Sign-Language-iOS" target="_blank" rel="noopener">使用CoreML深入学习的发声手语iOS应用程序</a></p></li><li><p><a href="https://github.com/sansansisi/SSIDCard" target="_blank" rel="noopener">iOS中国二代身份证号扫描识别</a></p></li></ol><h4 id="图像处理、滤镜"><a href="#图像处理、滤镜" class="headerlink" title="图像处理、滤镜"></a>图像处理、滤镜</h4><ul><li><p><a href="https://github.com/liyong03/YLGIFImage" target="_blank" rel="noopener">YLGIFImage</a> - 异步GIF图像解码器和图像查看器支持播放GIF图像。 它只是使用更少的内存</p></li><li><p><a href="https://github.com/BradLarson/GPUImage" target="_blank" rel="noopener">GPUImage</a> - 提供我们一个GPU-accelerated摄像头效果（图像和视频都可以）</p></li></ul><h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><ul><li><p><a href="https://github.com/nicklockwood/iCarousel" target="_blank" rel="noopener">iCarousel</a> - 各种3D变换的动画，以前用过，炫酷得没朋友</p></li><li><p><a href="https://github.com/jhurray/JHChainableAnimations" target="_blank" rel="noopener">JHChainableAnimations</a> - 链式动画编程</p></li><li><p><a href="https://github.com/ameizi/awesome-ios-animation" target="_blank" rel="noopener">awesome-iOS-animation</a> - iOS动画库整理收集</p></li></ul><h4 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h4><ul><li><a href="https://github.com/12207480/DOPDropDownMenu-Enhanced" target="_blank" rel="noopener">DOPDropDownMenu</a> - 下拉列表菜单</li></ul><h4 id="数据存储、数据库"><a href="#数据存储、数据库" class="headerlink" title="数据存储、数据库"></a>数据存储、数据库</h4><ul><li><p><a href="https://github.com/soffes/SAMKeychain" target="_blank" rel="noopener">SAMKeychain</a> - 钥匙串存储</p></li><li><p><a href="https://github.com/magicalpanda/MagicalRecord" target="_blank" rel="noopener">MagicalRecord</a> - 简化 Core Data 抓取数据的逻辑，推荐</p></li><li><p><a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">FMDB</a> - 对 sqlite 实现面向对象的封装</p></li></ul><h4 id="弹窗"><a href="#弹窗" class="headerlink" title="弹窗"></a>弹窗</h4><ul><li><p><a href="https://github.com/Jacky-An/JKAlertX" target="_blank" rel="noopener">JKAlertX</a> - iOS弹框，包含alert/actionsheet/collectionSheet/HUD四种样式，自动适配横屏，完美支持自定义。支持链式语法，简单优雅！</p></li><li><p><a href="https://github.com/cezarywojcik/CWStatusBarNotification" target="_blank" rel="noopener">CWStatusBarNotification</a>  - 状态栏通知</p></li></ul><h4 id="文本框、图文混排"><a href="#文本框、图文混排" class="headerlink" title="文本框、图文混排"></a>文本框、图文混排</h4><ul><li><p><a href="https://github.com/TTTAttributedLabel/TTTAttributedLabel" target="_blank" rel="noopener">TTTAttributedLabel</a> - 非常强大的Label，支持属性，数据诊断和链接</p></li><li><p><a href="https://github.com/12207480/TYAttributedLabel" target="_blank" rel="noopener">TYAttributedLabel</a> - 简单，强大的属性文本控件(无需了解CoreText)，支持图文混排显示，支持添加链接，image和UIView控件，支持自定义排版显示</p></li></ul><h4 id="加载进度条、指示器、提示框"><a href="#加载进度条、指示器、提示框" class="headerlink" title="加载进度条、指示器、提示框"></a>加载进度条、指示器、提示框</h4><ul><li><p><a href="https://github.com/jdg/MBProgressHUD" target="_blank" rel="noopener">MBProgressHUD</a></p></li><li><p><a href="https://github.com/SVProgressHUD/SVProgressHUD" target="_blank" rel="noopener">SVProgressHUD</a></p></li><li><p><a href="https://github.com/scalessec/Toast" target="_blank" rel="noopener">Toast</a></p></li></ul><h4 id="键盘类"><a href="#键盘类" class="headerlink" title="键盘类"></a>键盘类</h4><ul><li><p><a href="https://github.com/hackiftekhar/IQKeyboardManager" target="_blank" rel="noopener">IQKeyboardManager</a> - 全局键盘管理</p></li><li><p><a href="https://github.com/michaeltyson/TPKeyboardAvoiding" target="_blank" rel="noopener">TPKeyboardAvoiding</a> - 使用时设置scrollView的类为TPKeyboardAvoidingScrollView 即可支持xib</p></li></ul><h4 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h4><ul><li><p><a href="https://github.com/CoderMJLee/MJRefresh" target="_blank" rel="noopener">MJRefresh</a></p></li><li><p><a href="https://github.com/samvermette/SVPullToRefresh" target="_blank" rel="noopener">SVPullToRefresh</a> - 一行代码实现UIScrollView下拉刷新或者无限滚动</p></li></ul><h4 id="JSON解析"><a href="#JSON解析" class="headerlink" title="JSON解析"></a>JSON解析</h4><ul><li><a href="https://github.com/CoderMJLee/MJExtension" target="_blank" rel="noopener">MJExtension</a></li></ul><h4 id="图片浏览器"><a href="#图片浏览器" class="headerlink" title="图片浏览器"></a>图片浏览器</h4><ul><li><p><a href="https://github.com/indulgeIn/YBImageBrowser" target="_blank" rel="noopener">YBImageBrowser</a> - iOS图片浏览器（功能强大/性能优越）</p></li><li><p><a href="https://github.com/GodzzZZZ/MFPictureBrowser" target="_blank" rel="noopener">MFPictureBrowser</a> - 一个集成简单交互效果不错的图片浏览器， 内存以及CPU占用低，顺滑自然</p></li></ul><h4 id="弹幕"><a href="#弹幕" class="headerlink" title="弹幕"></a>弹幕</h4><ul><li><a href="https://github.com/iOS-Strikers/OCBarrage" target="_blank" rel="noopener">OCBarrage</a> - iOS 弹幕库 OCBarrage, 同时渲染5000条弹幕也不卡, 轻量, 可拓展, 高度自定义动画, 超高性能, 简单易上手</li></ul><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><ul><li><a href="https://github.com/liberalisman/iOS-InterviewQuestion-collection" target="_blank" rel="noopener">iOS 开发者面试题集锦</a></li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><ul><li><p><a href="https://casatwy.com/iosying-yong-jia-gou-tan-kai-pian.html" target="_blank" rel="noopener">iOS应用架构谈 开篇</a></p></li><li><p><a href="http://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html" target="_blank" rel="noopener">iOS应用架构谈 网络层设计方案</a></p></li><li><p><a href="http://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html" target="_blank" rel="noopener">iOS应用架构谈 view层的组织和调用方案</a></p></li></ul><h4 id="获取评价"><a href="#获取评价" class="headerlink" title="获取评价"></a>获取评价</h4><ul><li><a href="https://github.com/nicklockwood/iRate" target="_blank" rel="noopener">iRate</a> - 一个小库，你包含在你的项目里并且忘记询问用户去评价了——iRate会自动替你完成，在合适的时间里</li></ul><h4 id="销售App"><a href="#销售App" class="headerlink" title="销售App"></a>销售App</h4><ul><li><a href="https://github.com/JanC/TAPromotee" target="_blank" rel="noopener">TAPromotee</a> - 交叉推销你的app是最棒的销售策略之一，你可以在它们中免费实现。用这个库非常简单，你不再能为自己辩解为什么不用它——增加TAPromotee到你的podfile，配置、然后免费享受更多下载。</li></ul><h4 id="基础工具类以及Category"><a href="#基础工具类以及Category" class="headerlink" title="基础工具类以及Category"></a>基础工具类以及Category</h4><ul><li><p><a href="https://github.com/soffes/sstoolkit" target="_blank" rel="noopener">sstoolkit</a> - 一个不错的工具包，提供各种比如编码、加密、字符串处理等等东西</p></li><li><p><a href="https://github.com/ibireme/YYKit" target="_blank" rel="noopener">YYKit</a> - ibireme用心之作</p></li><li><p><a href="https://github.com/BlocksKit/BlocksKit" target="_blank" rel="noopener">BlocksKit</a> -  为基础类提供Block支持，很好用</p></li><li><p><a href="https://github.com/MatthewYork/DateTools" target="_blank" rel="noopener">DateTools</a> - 非常强大的日期处理工具</p></li><li><p><a href="https://github.com/kimziv/PinYin4Objc" target="_blank" rel="noopener">PinYin4Objc</a> - 拼音解析</p></li><li><p><a href="https://github.com/mattconnolly/ZipArchive" target="_blank" rel="noopener">ZipArchive</a> -  解压缩</p></li><li><p><a href="https://github.com/ViccAlexander/Chameleon" target="_blank" rel="noopener">Chameleon</a> - 扁平颜色框架，可以创建非常漂亮的颜色</p></li></ul><h4 id="OCR"><a href="#OCR" class="headerlink" title="OCR"></a>OCR</h4><ul><li><p><a href="https://github.com/gali8/Tesseract-OCR-iOS" target="_blank" rel="noopener">Tesseract-OCR-iOS</a> – 有关OCR文字识别项目。</p></li><li><p><a href="https://github.com/osnr/Screenotate" target="_blank" rel="noopener">Screenotate</a> – 支持 OCR 文字识别的载屏笔记 Mac 完整应用。</p></li></ul><h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><ul><li><a href="https://github.com/intuit/LocationManager" target="_blank" rel="noopener">LocationManager</a> – CoreLocation 使用起来还是比较麻烦的，需要授权，判断系统版本等等，所以推荐使用第三方框架LocationManager，使用Block，十分简单</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0C优秀的第三方库&quot;&gt;&lt;a href=&quot;#0C优秀的第三方库&quot; class=&quot;headerlink&quot; title=&quot;0C优秀的第三方库&quot;&gt;&lt;/a&gt;0C优秀的第三方库&lt;/h3&gt;&lt;h4 id=&quot;视频&quot;&gt;&lt;a href=&quot;#视频&quot; class=&quot;headerlink&quot; title=&quot;视频&quot;&gt;&lt;/a&gt;视频&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/xueyongwei/XYWSoundChanger&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;XYWSoundChanger&lt;/a&gt; - iOS视频变声器，对录制或下载的视频进行变声，对视频原声处理成大叔、萝莉、搞怪等效果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ChangbaDevs/KTVVideoProcess&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;KTVVideoProcess&lt;/a&gt; - 来自Changba iOS团队的高性能视频效果处理框架&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/yasginiwa/YGPlayer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;YGPlayer&lt;/a&gt; - iOS video player.（iOS播放器）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/36Kr-Mobile/KRVideoPlayer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;KRVideoPlayer&lt;/a&gt; - 36氪开源的视频播放器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;音频&quot;&gt;&lt;a href=&quot;#音频&quot; class=&quot;headerlink&quot; title=&quot;音频&quot;&gt;&lt;/a&gt;音频&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/douban/DOUAudioStreamer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DOUAudioStreamer&lt;/a&gt; - 豆瓣开源的音频播放器&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;AR&quot;&gt;&lt;a href=&quot;#AR&quot; class=&quot;headerlink&quot; title=&quot;AR&quot;&gt;&lt;/a&gt;AR&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/SherlockQi/HeavenMemoirs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HeavenMemoirs&lt;/a&gt; - AR相册&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ProjectDent/ARKit-CoreLocation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ARKit-CoreLocation&lt;/a&gt; - 将AR的高精度与GPS数据的比例结合起来&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="开发" scheme="https://fightingjoey.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Objective-C" scheme="https://fightingjoey.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Swift优秀的第三方库</title>
    <link href="https://fightingjoey.github.io/2018/07/28/%E5%BC%80%E5%8F%91/Swift%E4%BC%98%E7%A7%80%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    <id>https://fightingjoey.github.io/2018/07/28/开发/Swift优秀的第三方库/</id>
    <published>2018-07-28T07:30:41.000Z</published>
    <updated>2018-12-27T08:17:29.997Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Swift优秀的第三方库"><a href="#Swift优秀的第三方库" class="headerlink" title="Swift优秀的第三方库"></a>Swift优秀的第三方库</h3><p><a href="http://dev.swiftguide.cn" target="_blank" rel="noopener">Swift开发资源汇总</a></p><p><a href="https://github.com/imlifengfeng/iOSBlogAndTools" target="_blank" rel="noopener">iOS开发优秀博客和软件推荐</a></p><h4 id="数据库、数据存储"><a href="#数据库、数据存储" class="headerlink" title="数据库、数据存储"></a>数据库、数据存储</h4><ul><li><p><a href="https://github.com/realm/realm-cocoa" target="_blank" rel="noopener">realm-cocoa</a> - Realm 是一个移动端数据库：Core Data 和 SQLite 的替代品</p></li><li><p><a href="https://github.com/square/Valet" target="_blank" rel="noopener">Valet</a> - Valet 可以让你安全地在 iOS 或 OS X 钥匙链中存储数据，而不需要掌握任何钥匙链工作的知识。它支持在一台设备的多个应用（同一个开发者）间分享数据，以及在一个应用中在多个设备间利用 iCloud 进行分享。支持 Touch ID</p></li><li><p><a href="https://github.com/stephencelis/SQLite.swift" target="_blank" rel="noopener">SQLite.swift</a> - 简单、轻量，使用上最SQL的SQLite封装库</p></li><li><p><a href="https://github.com/modo-studio/SugarRecord" target="_blank" rel="noopener">SugarRecord</a> - 基于CoreData与REALM的好用封装</p></li></ul><h4 id="网络库、Network"><a href="#网络库、Network" class="headerlink" title="网络库、Network"></a>网络库、Network</h4><ul><li><p><a href="https://github.com/Moya/Moya" target="_blank" rel="noopener">Moya</a> - 用 Swift 写的网络抽象层</p></li><li><p><a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="noopener">Alamofire</a></p></li><li><p><a href="https://github.com/netguru/ResponseDetective" target="_blank" rel="noopener">ResponseDetective</a> - 一个非嵌入式框架，用于拦截应用程序和服务器之间的任何传出请求和传入响应以用于调试目的。</p></li></ul><a id="more"></a><h4 id="keychain"><a href="#keychain" class="headerlink" title="keychain"></a>keychain</h4><ul><li><a href="https://github.com/kishikawakatsumi/KeychainAccess" target="_blank" rel="noopener">KeychainAccess</a></li><li><a href="https://github.com/evgenyneu/keychain-swift" target="_blank" rel="noopener">keychain-swift</a></li></ul><h4 id="JSON解析"><a href="#JSON解析" class="headerlink" title="JSON解析"></a>JSON解析</h4><ul><li><a href="https://github.com/SwiftyJSON/SwiftyJSON" target="_blank" rel="noopener">SwiftyJSON</a> - 在 Swift 里处理 JSON 更好的方式，重点在于<strong>解析JSON数据</strong>，但是不能自动映射到model实例上。</li><li><a href="https://github.com/Hearst-DD/ObjectMapper" target="_blank" rel="noopener">ObjectMapper</a> - ObjectMapper是一个用Swift编写的框架，它使您可以轻松地将模型对象（类或结构体）转换为 JSON 和从 JSON 转换为模型。</li><li><a href="https://github.com/alibaba/HandyJSON" target="_blank" rel="noopener">HandyJSON</a> - 一个方便的swift json-object 序列化/反序列化库</li></ul><h4 id="监测分析工具"><a href="#监测分析工具" class="headerlink" title="监测分析工具"></a>监测分析工具</h4><ul><li><a href="https://www.ichdata.com/firebase-analytics-for-apps.html" target="_blank" rel="noopener">Firebase</a> - Firebase Analytics 是一个免费 app 监测解决方案，追踪 app 使用量、用户活跃度、以及事件；设置用户属性；创建自定义受众</li></ul><h4 id="异步UI、异步编程"><a href="#异步UI、异步编程" class="headerlink" title="异步UI、异步编程"></a>异步UI、异步编程</h4><ul><li><a href="https://github.com/facebookarchive/AsyncDisplayKit" target="_blank" rel="noopener">AsyncDisplayKit</a> - iOS app 的平滑异步用户界面。Facebook 为他们的 app <em>Paper</em> 创造了这个异步 UI SDK。如果你想让你的 app 总是每秒用 60 帧的速度来渲染，一定要看看这个库</li><li><a href="https://github.com/mxcl/PromiseKit" target="_blank" rel="noopener">PromiseKit</a></li><li><a href="https://github.com/yannickl/AwaitKit" target="_blank" rel="noopener">AwaitKit</a> - 受 ES8 Async/Await 启发，用 Swift 实现的异步编程库</li></ul><h4 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h4><ul><li><h4 id="图像处理、滤镜"><a href="#图像处理、滤镜" class="headerlink" title="图像处理、滤镜"></a>图像处理、滤镜</h4></li><li><p><a href="https://github.com/liyong03/YLGIFImage-Swift" target="_blank" rel="noopener">YLGIFImage-Swift</a> - 异步GIF图像解码器和图像查看器支持播放GIF图像。 它只是使用更少的内存</p></li></ul><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><ul><li><a href="https://github.com/ViccAlexander/Chameleon" target="_blank" rel="noopener">Chameleon</a> - iOS 的扁平颜色框架（Obj-C 和 Swift）</li></ul><h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><ul><li><a href="https://github.com/nickoneill/PermissionScope" target="_blank" rel="noopener">PermissionScope</a> - 巧妙的 iOS 权限 UI 和 统一 API</li></ul><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><ul><li><a href="https://github.com/nvzqz/FileKit" target="_blank" rel="noopener">FileKit</a> - 简单和富有表现力的 Swift 文件管理</li></ul><h4 id="UserDefaults"><a href="#UserDefaults" class="headerlink" title="UserDefaults"></a>UserDefaults</h4><ul><li><a href="https://github.com/radex/SwiftyUserDefaults" target="_blank" rel="noopener">SwiftyUserDefaults</a> - NSUserDefaults 的现代化 Swift API</li></ul><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><ul><li><a href="https://github.com/giginet/Crossroad" target="_blank" rel="noopener">Crossroad</a> - 轻松路由URL方案</li></ul><h4 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h4><ul><li><a href="https://github.com/yulingtianxia/YXYDashLayer" target="_blank" rel="noopener">YXYDashLayer</a> - 多彩的圆角矩形Dash边框</li></ul><h4 id="图片请求、图片浏览器"><a href="#图片请求、图片浏览器" class="headerlink" title="图片请求、图片浏览器"></a>图片请求、图片浏览器</h4><ul><li><p><a href="https://github.com/onevcat/Kingfisher" target="_blank" rel="noopener">Kingfisher</a> - 是一个轻量、纯 Swift 的库，可以从网络中异步下载和缓存图片</p></li><li><p><a href="https://github.com/Krisiacik/ImageViewer" target="_blank" rel="noopener">ImageViewer</a> - 模仿 Twitter 的图片浏览器</p></li><li><p><a href="https://github.com/Yummypets/YPImagePicker" target="_blank" rel="noopener">YPImagePicker</a> - 类似Instagram的图像选择器和滤镜</p></li></ul><h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><ul><li><a href="https://github.com/HeroTransitions/Hero" target="_blank" rel="noopener">Hero</a> - 是为了构建 iOS 试图控制器过渡动画的库。它在 UIKit 繁琐的过渡动画 API 之上提供了一个层，使得自定义过渡动画对于开发人员来说是一个轻松的任务。</li><li><a href="https://github.com/yapstudios/YapAnimator" target="_blank" rel="noopener">YapAnimator</a> - 快速友好的基于物理学的动画系统</li><li><a href="https://github.com/MengTo/Spring" target="_blank" rel="noopener">Spring</a> - 简化动画开发的Swift iOS动画库</li><li><a href="https://github.com/ninjaprox/NVActivityIndicatorView" target="_blank" rel="noopener">NVActivityIndicatorView</a> - 一系列令人惊叹的加载动画</li></ul><h4 id="邮件"><a href="#邮件" class="headerlink" title="邮件"></a>邮件</h4><ul><li><a href="https://github.com/onevcat/Hedwig" target="_blank" rel="noopener">Hedwig</a> - 像老板一样发送邮件到任意 SMTP 服务器，用 Swift 编写并且是跨平台的</li></ul><h4 id="设备信息"><a href="#设备信息" class="headerlink" title="设备信息"></a>设备信息</h4><ul><li><p><a href="https://github.com/dennisweissmann/DeviceKit" target="_blank" rel="noopener">DeviceKit</a> -  是 UIDevice 的值类型替换。轻松获取设备信息和电池电量。</p></li><li><p><a href="https://github.com/dani-gavrilov/GDPerformanceView-Swift" target="_blank" rel="noopener">GDPerformanceView</a> - 在状态栏上方显示 FPS，CPU 使用情况，app 和 iOS 版本，并通过 delegate 报告 FPS 和 CPU 使用情况。</p></li></ul><h4 id="图表、表格"><a href="#图表、表格" class="headerlink" title="图表、表格"></a>图表、表格</h4><ul><li><p><a href="https://github.com/danielgindi/Charts" target="_blank" rel="noopener">Charts</a> - 漂亮的线图、饼图、条形图、分布图、气泡图、雷达图还有更多种类，这是一个图表库。</p></li><li><p><a href="https://github.com/kevinzhow/PNChart-Swift" target="_blank" rel="noopener">PNChart-Swift</a> - 带动画效果的图表控件库</p></li><li><p><a href="https://github.com/cagricolak/CoreCharts" target="_blank" rel="noopener">CoreCharts</a> - 一个简单而强大的图表库</p></li></ul><h4 id="UITableViewCell"><a href="#UITableViewCell" class="headerlink" title="UITableViewCell"></a>UITableViewCell</h4><ul><li><a href="https://github.com/MortimerGoro/MGSwipeTableCell" target="_blank" rel="noopener">MGSwipeTableCell</a> - 一个易于使用的UITableViewCell子类，允许显示带有多种转换的可滑动按钮。</li></ul><h4 id="随机数据"><a href="#随机数据" class="headerlink" title="随机数据"></a>随机数据</h4><ul><li><a href="https://github.com/nvzqz/RandomKit" target="_blank" rel="noopener">RandomKit</a> - Swift 中的随机数据生成</li></ul><h4 id="引导页"><a href="#引导页" class="headerlink" title="引导页"></a>引导页</h4><ul><li><a href="https://github.com/mamaral/Onboard" target="_blank" rel="noopener">Onboard</a> - 只需几行代码，即可轻松创建漂亮，引人入胜的用户指导页体验。</li></ul><h4 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h4><ul><li><a href="https://github.com/Quick/Quick" target="_blank" rel="noopener">Quick</a> - Swift （以及 Objective-C）测试框架。</li><li><a href="https://github.com/Quick/Nimble" target="_blank" rel="noopener">Nimble</a> - Swift 和 Objective-C 的匹配器</li></ul><h4 id="内购框架"><a href="#内购框架" class="headerlink" title="内购框架"></a>内购框架</h4><ul><li><a href="https://github.com/bizz84/SwiftyStoreKit" target="_blank" rel="noopener">SwiftyStoreKit</a> - 是一个轻量的 app 内购框架，支持 iOS 8.0+，tvOS 9.0+和macOS 10.10+</li></ul><h4 id="日期、时间处理、日历"><a href="#日期、时间处理、日历" class="headerlink" title="日期、时间处理、日历"></a>日期、时间处理、日历</h4><ul><li><p><a href="https://github.com/naoty/Timepiece" target="_blank" rel="noopener">Timepiece</a> - Swift 里直观的日期处理。</p></li><li><p><a href="https://github.com/WenchaoD/FSCalendar" target="_blank" rel="noopener">FSCalendar</a> - 完全自定义的 iOS 日历库</p></li><li><p><a href="https://github.com/malcommac/SwiftDate" target="_blank" rel="noopener">SwiftDate</a> – 特别完整、强大的日期时间操作管理类库。它几乎涵盖了已知开源日期类库所有优秀特性。 他能帮你轻松处理时区，处理时间加减，计算到期时间等等场景下的问题。</p></li></ul><h4 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h4><ul><li><a href="https://github.com/krzyzanowskim/CryptoSwift" target="_blank" rel="noopener">CryptoSwift</a> - 是一个不断扩充的集合，包含了标准、安全、用 Swift 实现的加密算法</li></ul><h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><ul><li><a href="https://github.com/SnapKit/SnapKit" target="_blank" rel="noopener">Snapkit</a></li></ul><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><ul><li><a href="https://github.com/Danie1s/Tiercel" target="_blank" rel="noopener">Tiercel</a> - 简单易用且功能丰富的纯Swift下载框架</li></ul><h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><ul><li><a href="https://github.com/PrideChung/FontAwesomeKit" target="_blank" rel="noopener">FontAwesomeKit</a> - 用这个库你可以轻松地添加字体到你的项目里，并且在多种方式里使用它。</li></ul><h4 id="文本输入框、图文混排"><a href="#文本输入框、图文混排" class="headerlink" title="文本输入框、图文混排"></a>文本输入框、图文混排</h4><ul><li><p><a href="https://github.com/raulriera/TextFieldEffects" target="_blank" rel="noopener">TextFieldEffects</a> - 动效非常不错的文本输入框</p></li><li><p><a href="https://github.com/KyoheiG3/AttributedLabel" target="_blank" rel="noopener">AttributedLabel</a> - 显示性能数量级 UILabel 的 AttributedLabel</p></li></ul><h4 id="键盘类"><a href="#键盘类" class="headerlink" title="键盘类"></a>键盘类</h4><ul><li><p><a href="https://github.com/netyouli/WHC_KeyboardManager" target="_blank" rel="noopener">WHC_KeyboardManager</a> - Swift 轻量级的键盘管理器</p></li><li><p><a href="https://github.com/hackiftekhar/IQKeyboardManager" target="_blank" rel="noopener"><strong>IQKeyboardManager</strong></a></p></li></ul><h4 id="弹窗"><a href="#弹窗" class="headerlink" title="弹窗"></a>弹窗</h4><ul><li><a href="https://github.com/codestergit/SweetAlert-iOS" target="_blank" rel="noopener">SweetAlert</a> - 带动画效果弹窗封装类</li><li><a href="https://github.com/vikmeup/SCLAlertView-Swift" target="_blank" rel="noopener">SCLAlertView-Swift</a></li><li><a href="https://github.com/huri000/SwiftEntryKit" target="_blank" rel="noopener">SwiftEntryKit</a> - iOS上的横幅展示器库SwiftEntryKit</li><li><a href="https://github.com/CaliCastle/PopMenu" target="_blank" rel="noopener">PopMenu</a> - 一款酷酷且可定制的弹出层for iOS</li><li><a href="https://github.com/andreamazz/AMPopTip" target="_blank" rel="noopener">AMPopTip</a></li><li><a href="https://github.com/scalessec/Toast-Swift" target="_blank" rel="noopener">Toast-Swift</a></li><li><a href="https://github.com/dillidon/alerts-and-pickers" target="_blank" rel="noopener">alerts-and-pickers</a></li></ul><h4 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h4><ul><li><p><a href="https://github.com/jriosdev/iOSDropDown" target="_blank" rel="noopener">iOSDropDown</a>  —  可定制的iOS下拉菜单</p></li><li><p><a href="https://github.com/morizotter/SwiftyDrop" target="_blank" rel="noopener">SwiftyDrop</a> — 轻量、易用的小清新弹出列表及信息提示组件真心不错。</p></li></ul><h4 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h4><ul><li><a href="https://github.com/dasdom/BreakOutToRefresh" target="_blank" rel="noopener">BreakOutToRefresh</a></li><li><a href="https://github.com/andreamazz/GearRefreshControl" target="_blank" rel="noopener">GearRefreshControl</a></li><li><a href="https://github.com/jcavar/refresher" target="_blank" rel="noopener">refresher</a></li><li><a href="https://github.com/eggswift/pull-to-refresh" target="_blank" rel="noopener">pull-to-refresh</a></li></ul><h4 id="HUD"><a href="#HUD" class="headerlink" title="HUD"></a>HUD</h4><ul><li><a href="https://github.com/pkluz/PKHUD" target="_blank" rel="noopener">PKHUD</a></li><li><p><a href="https://github.com/johnlui/SwiftNotice" target="_blank" rel="noopener">SwiftNotice</a></p></li><li><p><a href="https://github.com/krimpedance/KRProgressHUD" target="_blank" rel="noopener">KRProgressHUD</a></p></li></ul><h4 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h4><ul><li><a href="https://github.com/YTiOSer/ScanCode_Swift" target="_blank" rel="noopener">ScanCode_Swift</a> - 二维码 VIN码扫描 支持拍照相册选择图片识别, 功能强大, UI漂亮, 集成简单!</li><li><a href="https://github.com/yannickl/QRCodeReader.swift" target="_blank" rel="noopener">QRCodeReader.swift</a> – QRCodeReader.swift一款简单的 QR 二维码阅读组件及示例，提供前后相机切换功能。</li></ul><h4 id="SegmentControl"><a href="#SegmentControl" class="headerlink" title="SegmentControl"></a>SegmentControl</h4><ul><li><a href="https://github.com/HeshamMegid/HMSegmentedControl-Swift" target="_blank" rel="noopener">HMSegmentedControl-Swift</a></li></ul><h4 id="UIKit扩展"><a href="#UIKit扩展" class="headerlink" title="UIKit扩展"></a>UIKit扩展</h4><ul><li><p><a href="https://github.com/nerdycat/Cupcake" target="_blank" rel="noopener">Cupcake</a> - 为iOS创建和布局UI组件的简单方法（Swift版本）</p></li><li><p><a href="https://github.com/Xiaoye220/EmptyDataSet-Swift" target="_blank" rel="noopener">EmptyDataSet-Swift</a> - 嵌入式 UITableView/UICollectionView 的父类类别，用于显示空的数据集，无论何时…</p></li><li><p><a href="https://github.com/Instagram/IGListKit" target="_blank" rel="noopener">Instagram/IGListKit</a> - 为了构建快速和可扩展的列表而生的数据驱动 UICollectionView 框架</p></li><li><p><a href="https://github.com/Ramotion/animated-tab-bar" target="_blank" rel="noopener">RAMAnimatedTabBarController</a> - 灵动的动画标签栏类库</p></li><li><p><a href="https://github.com/robbdimitrov/RDVTabBarController" target="_blank" rel="noopener">RDVTabBarController</a> - 一个定制化的TabBarController库，可动画显示隐藏tabbar栏，可定制tabbar栏</p></li><li><p><a href="https://github.com/chenjiang3/RDVTabBarControllerSwift" target="_blank" rel="noopener">RDVTabBarControllerSwift</a></p></li><li><p><a href="http://d.cocoachina.com/code/detail/286102" target="_blank" rel="noopener">SlideTapBar</a> – 滚动栏菜单，向上滚动时隐藏tabbar，向下滚动马上显示tabbar。</p></li><li><p><a href="https://github.com/lexrus/LTMorphingLabel" target="_blank" rel="noopener">LTMorphingLabel</a> - 各种文字动画效果</p></li><li><p><a href="https://github.com/arcangelw/WZRootNavigationController" target="_blank" rel="noopener">WZRootNavigationController</a> - iOS NavigationController过渡效果</p></li><li><p><a href="https://github.com/marcosgriselli/EasyTransitions" target="_blank" rel="noopener">EasyTransitions</a> - 一种创建自定义交互式UIViewController转换的简单方法</p></li><li><p><a href="https://github.com/neoneye/SwiftyFORM" target="_blank" rel="noopener">SwiftyFORM</a> – swift 表单输入框架（亮点是表单验证规则引擎），是我见过地最易用的 Swift 表单组件</p></li></ul><h4 id="基础工具类以及Category"><a href="#基础工具类以及Category" class="headerlink" title="基础工具类以及Category"></a>基础工具类以及Category</h4><ul><li><a href="https://github.com/FabrizioBrancati/BFKit-Swift" target="_blank" rel="noopener">BFKit</a> - 国外的一个大神写的很好用的分类，比较齐全 </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Swift优秀的第三方库&quot;&gt;&lt;a href=&quot;#Swift优秀的第三方库&quot; class=&quot;headerlink&quot; title=&quot;Swift优秀的第三方库&quot;&gt;&lt;/a&gt;Swift优秀的第三方库&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://dev.swiftguide.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swift开发资源汇总&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/imlifengfeng/iOSBlogAndTools&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;iOS开发优秀博客和软件推荐&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;数据库、数据存储&quot;&gt;&lt;a href=&quot;#数据库、数据存储&quot; class=&quot;headerlink&quot; title=&quot;数据库、数据存储&quot;&gt;&lt;/a&gt;数据库、数据存储&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/realm/realm-cocoa&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;realm-cocoa&lt;/a&gt; - Realm 是一个移动端数据库：Core Data 和 SQLite 的替代品&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/square/Valet&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Valet&lt;/a&gt; - Valet 可以让你安全地在 iOS 或 OS X 钥匙链中存储数据，而不需要掌握任何钥匙链工作的知识。它支持在一台设备的多个应用（同一个开发者）间分享数据，以及在一个应用中在多个设备间利用 iCloud 进行分享。支持 Touch ID&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/stephencelis/SQLite.swift&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SQLite.swift&lt;/a&gt; - 简单、轻量，使用上最SQL的SQLite封装库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/modo-studio/SugarRecord&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SugarRecord&lt;/a&gt; - 基于CoreData与REALM的好用封装&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;网络库、Network&quot;&gt;&lt;a href=&quot;#网络库、Network&quot; class=&quot;headerlink&quot; title=&quot;网络库、Network&quot;&gt;&lt;/a&gt;网络库、Network&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Moya/Moya&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Moya&lt;/a&gt; - 用 Swift 写的网络抽象层&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Alamofire/Alamofire&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Alamofire&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/netguru/ResponseDetective&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ResponseDetective&lt;/a&gt; - 一个非嵌入式框架，用于拦截应用程序和服务器之间的任何传出请求和传入响应以用于调试目的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="开发" scheme="https://fightingjoey.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Swift" scheme="https://fightingjoey.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>MacOS 终端 iTerm2 并配置 zsh</title>
    <link href="https://fightingjoey.github.io/2018/03/15/%E6%95%99%E7%A8%8B/MacOS%20%E7%BB%88%E7%AB%AF%20iTerm2%20%E5%B9%B6%E9%85%8D%E7%BD%AE%20zsh/"/>
    <id>https://fightingjoey.github.io/2018/03/15/教程/MacOS 终端 iTerm2 并配置 zsh/</id>
    <published>2018-03-15T09:29:12.000Z</published>
    <updated>2018-09-27T02:07:50.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mac-OS-终端-iTerm2"><a href="#Mac-OS-终端-iTerm2" class="headerlink" title="Mac OS 终端 iTerm2"></a>Mac OS 终端 iTerm2</h1><p>之前一直使用的 Mac OS 自带的终端，觉得也还可以，后来看大神 onevcat 的直播视频，发现他用的是 iTerm，真的是非常好用，于是自己也开始倒腾起来。</p><a id="more"></a><h2 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h2><h3 id="1-下载安装"><a href="#1-下载安装" class="headerlink" title="1.下载安装"></a>1.下载安装</h3><p><a href="https://www.iterm2.com/downloads.html" target="_blank" rel="noopener">官网下载地址</a></p><p>下载下来直接是一个 App ，你可以直接打开，也可以把它拖到 Applications 目录下。</p><h3 id="2-偏好设置"><a href="#2-偏好设置" class="headerlink" title="2.偏好设置"></a>2.偏好设置</h3><p><code>菜单</code> —&gt; <code>Preferences</code> —&gt; <code>Profiles</code></p><p><img src="https://upload-images.jianshu.io/upload_images/1507703-7944f7306fcdbe4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Profiles.png"></p><p>在左侧的列表里显示了你的所有配置文件（<code>Profile</code>），目前列表里只有一个默认的 <code>Default</code>，这个是iTerm默认的窗口模板配置文件，我们接下来创建自己的窗口配置文件。</p><p>点击列表下方的 <code>+</code> 号，新建配置文件</p><p><img src="https://upload-images.jianshu.io/upload_images/1507703-9da514c8c4c54963.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="newProfile.png"></p><p><code>General</code> 里面填写基础的配置：</p><ul><li><strong>Name</strong>：配置文件名称</li><li><strong>Shortcut Key</strong>：打开该窗口的快捷键</li><li><strong>Tags</strong>：标签，方便在左侧列表快速查找到该配置文件</li><li><strong>Badge</strong>：标记，在窗口上显示你的个人标识。</li></ul><p><code>Colors</code> 里面设置颜色相关的配置：</p><ul><li><strong>Foreground</strong>：前景色，窗口文字颜色</li><li><strong>Background</strong>：窗口背景色</li><li><strong>Links</strong>：链接的颜色</li><li><strong>Selection</strong>：选中内容的背景色</li><li><strong>Selected Text</strong>：选中文字的颜色</li><li><strong>Badge</strong>：标记的颜色</li><li><strong>Cursor</strong>：光标的颜色</li></ul><blockquote><p>这里还可以去网上下载主题配色，然后使用别人配置的主题，<a href="https://github.com/mbadolato/iTerm2-Color-Schemes" target="_blank" rel="noopener">下载地址</a>，下载完成以后，选择<code>Color Presets</code> —&gt; <code>Import</code>，选择你下载的文件夹，找到目录下的<code>schemes</code>文件夹，选中里面你想要的主题，点击<code>open</code>导入，然后就可以使用了。</p></blockquote><blockquote><p><a href="http://blog.csdn.net/zhongtiankai/article/details/71597499" target="_blank" rel="noopener">修改mac 终端(terminal)字体颜色</a></p></blockquote><p><code>Text</code> 里面设置窗口文字相关的配置：</p><ul><li><strong>Cursor</strong>：光标的样式</li><li><strong>Font</strong>：文字字体</li></ul><p><code>Window</code> 里设置窗口相关的配置：</p><ul><li><strong>Transparency</strong>：窗口的透明度</li><li><strong>Background Image</strong>：窗口的背景图片</li></ul><h3 id="3-亮点功能"><a href="#3-亮点功能" class="headerlink" title="3.亮点功能"></a>3.亮点功能</h3><h4 id="快速隐藏和显示"><a href="#快速隐藏和显示" class="headerlink" title="快速隐藏和显示"></a>快速隐藏和显示</h4><p><code>Profiles</code> —&gt; <code>Keys</code> —&gt; <code>Hotkey</code>，选中，默认的快捷键是：<code>option + Space</code></p><h4 id="自动补齐"><a href="#自动补齐" class="headerlink" title="自动补齐"></a>自动补齐</h4><p>iTerm2 可以自动补齐命令，输入若干字符，按<code>Command + ;</code>弹出自动补齐窗口，列出曾经使用过的命令。</p><h4 id="时间轴"><a href="#时间轴" class="headerlink" title="时间轴"></a>时间轴</h4><p>如果你想查看你最近一段时间执行的操作，可以使用时间轴功能。</p><p>快捷键：<code>Command + Option + B</code></p><h4 id="智能选中"><a href="#智能选中" class="headerlink" title="智能选中"></a>智能选中</h4><p>在 iTerm2 中，双击选中，三击选中整行。可以识别网址，引号引起的字符串，邮箱地址等。</p><p>在 iTerm2 中，选中即复制。即任何选中状态的字符串都被放到了系统剪切板中。</p><h4 id="强大的-Command-键"><a href="#强大的-Command-键" class="headerlink" title="强大的 Command 键"></a>强大的 Command 键</h4><p>按住<code>command</code>键：</p><ul><li>可以拖拽选中的字符串</li><li>点击<code>url</code>：调用默认浏览器访问该网址</li><li>点击文件：调用默认程序打开文件</li><li>点击文件夹：在<code>Finder</code>中打开该文件夹</li><li>同时按住<code>option</code>键，可以以矩形选中</li></ul><h4 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h4><table><thead><tr><th style="text-align:left">快捷键</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>Command + Shift + H</code></td><td style="text-align:center">历史粘贴记录</td></tr><tr><td style="text-align:left"><code>Command + Shift + ;</code></td><td style="text-align:center">历史命令记录</td></tr><tr><td style="text-align:left"><code>Command + D</code></td><td style="text-align:center">同个窗口横向分屏</td></tr><tr><td style="text-align:left"><code>Command + Shift + D</code></td><td style="text-align:center">同个窗口竖向分屏</td></tr><tr><td style="text-align:left"><code>Command + Option + E</code></td><td style="text-align:center">快速预览所有窗口</td></tr><tr><td style="text-align:left"><code>Command + /</code></td><td style="text-align:center">高亮当前鼠标的位置</td></tr><tr><td style="text-align:left"><code>Command + T</code></td><td style="text-align:center">新建窗口</td></tr><tr><td style="text-align:left"><code>Command + W</code></td><td style="text-align:center">关闭窗口</td></tr><tr><td style="text-align:left"><code>Command + 左右方向键</code></td><td style="text-align:center">切换窗口</td></tr><tr><td style="text-align:left"><code>Command + 上下方向键</code></td><td style="text-align:center">上下滚动内容</td></tr><tr><td style="text-align:left"><code>Command + 数字</code></td><td style="text-align:center">切换至指定窗口</td></tr><tr><td style="text-align:left"><code>Command + ,</code></td><td style="text-align:center">打开偏好设置</td></tr><tr><td style="text-align:left"><code>Command + F</code></td><td style="text-align:center">智能查找</td></tr></tbody></table><h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><h3 id="1-下载安装-1"><a href="#1-下载安装-1" class="headerlink" title="1.下载安装"></a>1.下载安装</h3><p>Mac 系统自带了<code>zsh</code>, 一般不是最新版，如果需要最新版可通过<code>Homebrew</code>来安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install zsh</span><br></pre></td></tr></table></figure><p>可通过 <code>zsh --version</code> 查看<code>zsh</code>的版本。</p><p>安装完成以后，将<code>zsh</code>设置为默认的<code>Shell</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><h3 id="2-安装-oh-my-zsh"><a href="#2-安装-oh-my-zsh" class="headerlink" title="2.安装 oh my zsh"></a>2.安装 oh my zsh</h3><p>使用 <code>crul</code> 安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure><p>使用 <code>wget</code> 安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</span><br></pre></td></tr></table></figure><p>安装成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Cloning Oh My Zsh...</span><br><span class="line">Cloning into &apos;/root/.oh-my-zsh&apos;...</span><br><span class="line">remote: Counting objects: 712, done.</span><br><span class="line">remote: Compressing objects: 100% (584/584), done.</span><br><span class="line">remote: Total 712 (delta 15), reused 522 (delta 4), pack-reused 0</span><br><span class="line">Receiving objects: 100% (712/712), 443.58 KiB | 27.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (15/15), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line">Looking for an existing zsh config...</span><br><span class="line">Using the Oh My Zsh template file and adding it to ~/.zshrc</span><br><span class="line">Copying your current PATH and adding it to the end of ~/.zshrc for you.</span><br><span class="line">Time to change your default shell to zsh!</span><br><span class="line">        __                                     __</span><br><span class="line"> ____  / /_     ____ ___  __  __   ____  _____/ /_</span><br><span class="line">/ __ \/ __ \   / __ `__ \/ / / /  /_  / / ___/ __ \</span><br><span class="line">/ /_/ / / / /  / / / / / / /_/ /    / /_(__  ) / / /</span><br><span class="line">\____/_/ /_/  /_/ /_/ /_/\__, /    /___/____/_/ /_/</span><br><span class="line">                       /____/                       ....is now installed!</span><br><span class="line"></span><br><span class="line">Please look over the ~/.zshrc file to select plugins, themes, and options.</span><br><span class="line">p.s. Follow us at https://twitter.com/ohmyzsh.</span><br><span class="line">p.p.s. Get stickers and t-shirts at http://shop.planetargon.com.</span><br></pre></td></tr></table></figure><blockquote><p>安装完成以后，默认<code>Shell</code>的<code>~/.bashrc</code>文件默认不再加载了，替代的是<code>~/.zlogin</code>和<code>~/.zshrc</code>。所以如果你在<code>~/.bashrc</code>里配置了某些设置，需要把她们复制到<code>~/.zshrc</code>中。</p></blockquote><h4 id="oh-my-zsh-目录结构"><a href="#oh-my-zsh-目录结构" class="headerlink" title="oh my zsh 目录结构"></a>oh my zsh 目录结构</h4><p>进入<code>~/.oh-my-zsh</code>目录后，看看该目录的结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~ ls ~/.oh-my-zsh</span><br><span class="line">CONTRIBUTING.md cache           log             templates</span><br><span class="line">LICENSE.txt     custom          oh-my-zsh.sh    themes</span><br><span class="line">README.md       lib             plugins         tools</span><br></pre></td></tr></table></figure><ul><li>lib 提供了核心功能的脚本库</li><li>tools 提供安装、升级等功能的快捷工具</li><li>plugins 自带插件的存在放位置</li><li>templates 自带模板的存在放位置</li><li>themes  自带主题文件的存在放位置</li><li>custom 个性化配置目录，自安装的插件和主题可放这里</li></ul><h3 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.配置</h3><p><code>zsh</code> 的配置主要集中在<code>~/.zshrc</code>里，用 <code>vim</code> 或你喜欢的其他编辑器打开<code>.zshrc</code>。</p><p>可以在此处定义自己的环境变量和别名，当然，<code>oh my zsh</code> 在安装时已经自动读取当前的环境变量并进行了设置，你可以继续追加其他环境变量。</p><h4 id="别名设置："><a href="#别名设置：" class="headerlink" title="别名设置："></a>别名设置：</h4><p><code>zsh</code>不仅可以设置通用别名，还能针对文件类型设置对应的打开程序，比如：</p><ul><li><code>alias -s html=vi</code>，意思就是你在命令行输入 <code>hello.html</code>，<code>zsh</code>会为你自动打开<code>vim</code>并读取<code>hello.html</code>； </li><li><code>alias -s gz=&#39;tar -xzvf&#39;</code>，表示自动解压后缀为<code>gz</code>的压缩包。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">alias cls=&apos;clear&apos;</span><br><span class="line">alias ll=&apos;ls -l&apos;</span><br><span class="line">alias la=&apos;ls -a&apos;</span><br><span class="line">alias vi=&apos;vim&apos;</span><br><span class="line">alias javac=&quot;javac -J-Dfile.encoding=utf8&quot;</span><br><span class="line">alias grep=&quot;grep --color=auto&quot;</span><br><span class="line">alias -s html=vi   # 在命令行直接输入后缀为 html 的文件名，会在 vim 中打开</span><br><span class="line">alias -s rb=vi     # 在命令行直接输入 ruby 文件，会在 vim 中打开</span><br><span class="line">alias -s py=vi       # 在命令行直接输入 python 文件，会用 vim 中打开，以下类似</span><br><span class="line">alias -s js=vi</span><br><span class="line">alias -s c=vi</span><br><span class="line">alias -s java=vi</span><br><span class="line">alias -s txt=vi</span><br><span class="line">alias -s gz=&apos;tar -xzvf&apos;</span><br><span class="line">alias -s tgz=&apos;tar -xzvf&apos;</span><br><span class="line">alias -s zip=&apos;unzip&apos;</span><br><span class="line">alias -s bz2=&apos;tar -xjvf&apos;</span><br></pre></td></tr></table></figure><h4 id="主题设置："><a href="#主题设置：" class="headerlink" title="主题设置："></a>主题设置：</h4><p><code>oh my zsh</code> 提供了数十种主题，相关文件在<code>~/.oh-my-zsh/themes</code>目录下，你可以自己选择，也可以自己编写主题。</p><p>在<code>.zshrc</code>里找到<code>ZSH_THEME</code>，就可以设置主题了，默认主题是：<code>ZSH_THEME=”robbyrussell”</code></p><p><code>ZSH_THEME=&quot;random&quot;</code>，主题设置为随机，这样我们每打开一个窗口，都会随机在默认主题中选择一个。</p><h4 id="插件设置："><a href="#插件设置：" class="headerlink" title="插件设置："></a>插件设置：</h4><p><code>oh my zsh</code>项目提供了完善的插件体系，相关的文件在<code>~/.oh-my-zsh/plugins</code>目录下，默认提供了100多种，大家可以根据自己的实际学习和工作环境采用，想了解每个插件的功能，只要打开相关目录下的 <code>zsh</code> 文件看一下就知道了。插件也是在<code>.zshrc</code>里配置，找到<code>plugins</code>关键字，你就可以加载自己的插件了，系统默认加载<code>git</code>，你可以在后面追加内容，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins=(git zsh-autosuggestions autojump zsh-syntax-highlighting)</span><br></pre></td></tr></table></figure><h5 id="安装-zsh-autosuggestions"><a href="#安装-zsh-autosuggestions" class="headerlink" title="安装 zsh-autosuggestions"></a>安装 <code>zsh-autosuggestions</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure><p>添加至 <code>plugins</code></p><h5 id="安装-zsh-syntax-highlighting"><a href="#安装-zsh-syntax-highlighting" class="headerlink" title="安装 zsh-syntax-highlighting"></a>安装 <code>zsh-syntax-highlighting</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><p>添加至 <code>plugins</code></p><h3 id="卸载oh-my-zsh"><a href="#卸载oh-my-zsh" class="headerlink" title="卸载oh my zsh"></a>卸载oh my zsh</h3><p>直接在终端中，运行<code>uninstall_oh_my_zsh</code>既可以卸载。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://macshuo.com/?p=676" target="_blank" rel="noopener">终极 Shell zsh</a></p><p><a href="http://wdxtub.com/2016/02/18/oh-my-zsh/" target="_blank" rel="noopener">zsh 全程指南</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Mac-OS-终端-iTerm2&quot;&gt;&lt;a href=&quot;#Mac-OS-终端-iTerm2&quot; class=&quot;headerlink&quot; title=&quot;Mac OS 终端 iTerm2&quot;&gt;&lt;/a&gt;Mac OS 终端 iTerm2&lt;/h1&gt;&lt;p&gt;之前一直使用的 Mac OS 自带的终端，觉得也还可以，后来看大神 onevcat 的直播视频，发现他用的是 iTerm，真的是非常好用，于是自己也开始倒腾起来。&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="https://fightingjoey.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Mac" scheme="https://fightingjoey.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>iOS WKWebView https 加载不受信任的站点</title>
    <link href="https://fightingjoey.github.io/2018/03/07/%E5%BC%80%E5%8F%91/iOS%20WKWebView%20https%20%E5%8A%A0%E8%BD%BD%E4%B8%8D%E5%8F%97%E4%BF%A1%E4%BB%BB%E7%9A%84%E7%AB%99%E7%82%B9/"/>
    <id>https://fightingjoey.github.io/2018/03/07/开发/iOS WKWebView https 加载不受信任的站点/</id>
    <published>2018-03-07T07:17:22.000Z</published>
    <updated>2018-09-27T02:09:26.030Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>公司要对接一个第三方平台，然后就有了一个可奇葩的逻辑，用户填写完相关信息后，点击提交，然后服务器返回一个网页的源代码……需要用WebView加载这个网页。</p><p>实现的时候发现，我自己写的简单的网页源码可以加载，但是服务器返回的就是无法加载。后来把源码保存成文件以后，用浏览器打开发现，该网页链接的站点是一个不受信任的站点，应该是因为服务器证书无效而不受信任。</p><a id="more"></a><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">self.wkWeb.navigationDelegate = self</span><br><span class="line"></span><br><span class="line">// 实现以下代理方法</span><br><span class="line">func webView(_ webView: WKWebView, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -&gt; Void) &#123;</span><br><span class="line">     let cred = URLCredential.init(trust: challenge.protectionSpace.serverTrust!)</span><br><span class="line">     completionHandler(.useCredential, cred)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果是OC</span><br><span class="line">- (void)webView:(WKWebView *)webView didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler &#123;</span><br><span class="line">    if ([challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) &#123;</span><br><span class="line">        NSURLCredential * card = [[NSURLCredential alloc] initWithTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">        completionHandler(NSURLSessionAuthChallengeUseCredential,card);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>有朋友说还需要在 <code>plist</code> 文件中设置：</p><p>将<code>Allow Arbitrary Loads in Web Content</code> 置为 <code>YES</code>，或者将<code>Allow Arbitrary Loads</code>置位<code>YES</code>。</p><p>但是我实际测试以后发现，不设置也可以打开，可能是具体情况不同的原因吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h3&gt;&lt;p&gt;公司要对接一个第三方平台，然后就有了一个可奇葩的逻辑，用户填写完相关信息后，点击提交，然后服务器返回一个网页的源代码……需要用WebView加载这个网页。&lt;/p&gt;
&lt;p&gt;实现的时候发现，我自己写的简单的网页源码可以加载，但是服务器返回的就是无法加载。后来把源码保存成文件以后，用浏览器打开发现，该网页链接的站点是一个不受信任的站点，应该是因为服务器证书无效而不受信任。&lt;/p&gt;
    
    </summary>
    
      <category term="开发" scheme="https://fightingjoey.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://fightingjoey.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装SublimeText3并配置相关内容</title>
    <link href="https://fightingjoey.github.io/2017/12/23/%E6%95%99%E7%A8%8B/Ubuntu%E5%AE%89%E8%A3%85SublimeText3%E5%B9%B6%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/"/>
    <id>https://fightingjoey.github.io/2017/12/23/教程/Ubuntu安装SublimeText3并配置相关内容/</id>
    <published>2017-12-23T12:49:51.000Z</published>
    <updated>2018-09-27T02:08:32.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu安装SublimeText3并配置相关内容"><a href="#Ubuntu安装SublimeText3并配置相关内容" class="headerlink" title="Ubuntu安装SublimeText3并配置相关内容"></a>Ubuntu安装SublimeText3并配置相关内容</h1><h2 id="下载安装SublimeText3"><a href="#下载安装SublimeText3" class="headerlink" title="下载安装SublimeText3"></a>下载安装SublimeText3</h2><h4 id="1-下载SublimeText3的安装包，官网地址"><a href="#1-下载SublimeText3的安装包，官网地址" class="headerlink" title="1.下载SublimeText3的安装包，官网地址"></a>1.下载<code>SublimeText3</code>的安装包，<a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">官网地址</a></h4><h4 id="2-解压安装包"><a href="#2-解压安装包" class="headerlink" title="2.解压安装包"></a>2.解压安装包</h4><h4 id="3-解压获得-sublime-text-3-文件夹，将该文件夹重命名为sublime-text"><a href="#3-解压获得-sublime-text-3-文件夹，将该文件夹重命名为sublime-text" class="headerlink" title="3.解压获得 sublime_text_3 文件夹，将该文件夹重命名为sublime_text"></a>3.解压获得 <code>sublime_text_3</code> 文件夹，将该文件夹重命名为<code>sublime_text</code></h4><h4 id="4-点击右键，打开终端，输入下面代码，把文件夹移动到-opt"><a href="#4-点击右键，打开终端，输入下面代码，把文件夹移动到-opt" class="headerlink" title="4.点击右键，打开终端，输入下面代码，把文件夹移动到/opt/"></a>4.点击右键，打开终端，输入下面代码，把文件夹移动到<code>/opt/</code></h4><p><code>sudo mv sublime_text /opt/</code></p><a id="more"></a><h4 id="5-在-usr-bin-下创建链接"><a href="#5-在-usr-bin-下创建链接" class="headerlink" title="5.在/usr/bin/下创建链接"></a>5.在<code>/usr/bin/</code>下创建链接</h4><p><code>sudo ln -s /opt/sublime_text/sublime_text /usr/bin/sublime</code></p><h4 id="6-现在你在终端已经可以打开sublime-text-3"><a href="#6-现在你在终端已经可以打开sublime-text-3" class="headerlink" title="6.现在你在终端已经可以打开sublime text 3"></a>6.现在你在终端已经可以打开<code>sublime text 3</code></h4><p><code>sublime</code></p><h4 id="7-当然为了方便我们需要建立一个图标链接"><a href="#7-当然为了方便我们需要建立一个图标链接" class="headerlink" title="7.当然为了方便我们需要建立一个图标链接"></a>7.当然为了方便我们需要建立一个图标链接</h4><p><code>sudo sublime /usr/share/applications/sublime.desktop</code></p><p>把下面内容粘贴进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Version=3.0</span><br><span class="line">Type=Application</span><br><span class="line">Name=sublime</span><br><span class="line">GenericName=Text Editor</span><br><span class="line">Comment=Sophisticated text editor for code, markup and prose</span><br><span class="line">Exec=/opt/sublime_text/sublime_text %F</span><br><span class="line">Terminal=false</span><br><span class="line">MimeType=text/plain;</span><br><span class="line">Icon=/opt/sublime_text/Icon/48x48/sublime_text.png</span><br><span class="line">Categories=TextEditor;Development;</span><br><span class="line">StartupNotify=true</span><br><span class="line">Actions=Window;Document;</span><br><span class="line"></span><br><span class="line">[Desktop Action Window]</span><br><span class="line">Name=New Window</span><br><span class="line">Exec=/opt/sublime_text/sublime_text -n</span><br><span class="line">OnlyShowIn=Unity;</span><br><span class="line"></span><br><span class="line">[Desktop Action Document]</span><br><span class="line">Name=New File</span><br><span class="line">Exec=/opt/sublime_text/sublime_text --command new_file</span><br><span class="line">OnlyShowIn=Unity;</span><br></pre></td></tr></table></figure><h2 id="SublimeText3无法输入中文的解决办法"><a href="#SublimeText3无法输入中文的解决办法" class="headerlink" title="SublimeText3无法输入中文的解决办法"></a>SublimeText3无法输入中文的解决办法</h2><h4 id="1-下载我们需要的文件，打开终端，输入"><a href="#1-下载我们需要的文件，打开终端，输入" class="headerlink" title="1.下载我们需要的文件，打开终端，输入"></a>1.下载我们需要的文件，打开终端，输入</h4><p><code>git clone https://github.com/lyfeyaj/sublime-text-imfix.git</code></p><h4 id="2-将下载的文件解压之后，移到当前目录（～目录下边），然后执行下边命令"><a href="#2-将下载的文件解压之后，移到当前目录（～目录下边），然后执行下边命令" class="headerlink" title="2.将下载的文件解压之后，移到当前目录（～目录下边），然后执行下边命令"></a>2.将下载的文件解压之后，移到当前目录（～目录下边），然后执行下边命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/sublime-text-imfix （前提：解压后的sublime-text-imfix必须在~目录下） </span><br><span class="line">sudo cp ./lib/libsublime-imfix.so /opt/sublime_text/ </span><br><span class="line">sudo cp ./src/subl /usr/bin/</span><br></pre></td></tr></table></figure><blockquote><p>这时候<code>/usr/bin</code>里有两个文件都可以打开<code>SublimeText</code>，<code>subl</code>和<code>sublime</code>，但是用<code>subl</code>打开可以输入中文，而<code>sublime</code>打开不行，如果觉得不好的话，可以把<code>sublime</code>删除掉</p></blockquote><h4 id="3-最后把sublime都关掉，然后在终端输入subl，就可以在sublime使用中文了"><a href="#3-最后把sublime都关掉，然后在终端输入subl，就可以在sublime使用中文了" class="headerlink" title="3.最后把sublime都关掉，然后在终端输入subl，就可以在sublime使用中文了"></a>3.最后把<code>sublime</code>都关掉，然后在终端输入<code>subl</code>，就可以在<code>sublime</code>使用中文了</h4><blockquote><p>这个时候，必须在终端输入<code>subl</code>启动<code>SublimeText</code>才起作用的</p></blockquote><h4 id="4-如果想通过图标打开Sublime也可以输入中文的话，解决办法如下"><a href="#4-如果想通过图标打开Sublime也可以输入中文的话，解决办法如下" class="headerlink" title="4.如果想通过图标打开Sublime也可以输入中文的话，解决办法如下"></a>4.如果想通过图标打开<code>Sublime</code>也可以输入中文的话，解决办法如下</h4><p>打开终端，输入以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/bin/subl   #查看一下subl命令做了什么</span><br><span class="line"></span><br><span class="line">export LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so</span><br><span class="line">exec /opt/sublime_text/sublime_text &quot;$@&quot;hupeng@hupeng-vm:~$</span><br></pre></td></tr></table></figure><blockquote><p>注: export命令将变量导出，并使之在能在子shell中有效</p></blockquote><p>最终，解决办法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /usr/share/applications/sublime_text.desktop</span><br><span class="line"></span><br><span class="line"># 修改三个`Exec`，在前面加入`env LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so`</span><br><span class="line"></span><br><span class="line">Exec=env LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so /opt/sublime_text/sublime_text %F</span><br><span class="line">Exec=env LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so /opt/sublime_text/sublime_text -n</span><br><span class="line">Exec=env LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so /opt/sublime_text/sublime_text --command new_file</span><br></pre></td></tr></table></figure><p>修改完成后，<code>/usr/share/applications/sublime_text.desktop</code>内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Version=1.0</span><br><span class="line">Type=Application</span><br><span class="line">Name=Sublime Text</span><br><span class="line">GenericName=Text Editor</span><br><span class="line">Comment=Sophisticated text editor for code, markup and prose</span><br><span class="line">Exec=env LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so /opt/sublime_text/sublime_text %F</span><br><span class="line">Terminal=false</span><br><span class="line">MimeType=text/plain;</span><br><span class="line">Icon=sublime-text</span><br><span class="line">Categories=TextEditor;Development;</span><br><span class="line">StartupNotify=true</span><br><span class="line">Actions=Window;Document;</span><br><span class="line"></span><br><span class="line">[Desktop Action Window]</span><br><span class="line">Name=New Window</span><br><span class="line">Exec=env LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so /opt/sublime_text/sublime_text -n</span><br><span class="line">OnlyShowIn=Unity;</span><br><span class="line"></span><br><span class="line">[Desktop Action Document]</span><br><span class="line">Name=New File</span><br><span class="line">Exec=env LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so /opt/sublime_text/sublime_text --command new_file</span><br><span class="line">OnlyShowIn=Unity;</span><br></pre></td></tr></table></figure><h2 id="添加Python3-Build-System"><a href="#添加Python3-Build-System" class="headerlink" title="添加Python3 Build System"></a>添加Python3 Build System</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;cmd&quot;: [&quot;/home/hp/anaconda3/envs/tensorflow/bin/python3&quot;,&quot;-u&quot;,&quot;$file&quot;],</span><br><span class="line">    &quot;file_regex&quot;: &quot;^[ ]*File \&quot;(...*?)\&quot;, line ([0-9]*)&quot;,</span><br><span class="line">    &quot;selector&quot;: &quot;source.python&quot;,</span><br><span class="line">    &quot;env&quot;: &#123;&quot;LANG&quot;: &quot;en_US.UTF-8&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Ubuntu安装SublimeText3并配置相关内容&quot;&gt;&lt;a href=&quot;#Ubuntu安装SublimeText3并配置相关内容&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu安装SublimeText3并配置相关内容&quot;&gt;&lt;/a&gt;Ubuntu安装SublimeText3并配置相关内容&lt;/h1&gt;&lt;h2 id=&quot;下载安装SublimeText3&quot;&gt;&lt;a href=&quot;#下载安装SublimeText3&quot; class=&quot;headerlink&quot; title=&quot;下载安装SublimeText3&quot;&gt;&lt;/a&gt;下载安装SublimeText3&lt;/h2&gt;&lt;h4 id=&quot;1-下载SublimeText3的安装包，官网地址&quot;&gt;&lt;a href=&quot;#1-下载SublimeText3的安装包，官网地址&quot; class=&quot;headerlink&quot; title=&quot;1.下载SublimeText3的安装包，官网地址&quot;&gt;&lt;/a&gt;1.下载&lt;code&gt;SublimeText3&lt;/code&gt;的安装包，&lt;a href=&quot;https://www.sublimetext.com/3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网地址&lt;/a&gt;&lt;/h4&gt;&lt;h4 id=&quot;2-解压安装包&quot;&gt;&lt;a href=&quot;#2-解压安装包&quot; class=&quot;headerlink&quot; title=&quot;2.解压安装包&quot;&gt;&lt;/a&gt;2.解压安装包&lt;/h4&gt;&lt;h4 id=&quot;3-解压获得-sublime-text-3-文件夹，将该文件夹重命名为sublime-text&quot;&gt;&lt;a href=&quot;#3-解压获得-sublime-text-3-文件夹，将该文件夹重命名为sublime-text&quot; class=&quot;headerlink&quot; title=&quot;3.解压获得 sublime_text_3 文件夹，将该文件夹重命名为sublime_text&quot;&gt;&lt;/a&gt;3.解压获得 &lt;code&gt;sublime_text_3&lt;/code&gt; 文件夹，将该文件夹重命名为&lt;code&gt;sublime_text&lt;/code&gt;&lt;/h4&gt;&lt;h4 id=&quot;4-点击右键，打开终端，输入下面代码，把文件夹移动到-opt&quot;&gt;&lt;a href=&quot;#4-点击右键，打开终端，输入下面代码，把文件夹移动到-opt&quot; class=&quot;headerlink&quot; title=&quot;4.点击右键，打开终端，输入下面代码，把文件夹移动到/opt/&quot;&gt;&lt;/a&gt;4.点击右键，打开终端，输入下面代码，把文件夹移动到&lt;code&gt;/opt/&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;&lt;code&gt;sudo mv sublime_text /opt/&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="https://fightingjoey.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Linux" scheme="https://fightingjoey.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Swift面向协议编程总结</title>
    <link href="https://fightingjoey.github.io/2017/11/13/%E5%BC%80%E5%8F%91/Swift%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B/"/>
    <id>https://fightingjoey.github.io/2017/11/13/开发/Swift面向协议编程/</id>
    <published>2017-11-13T07:27:38.000Z</published>
    <updated>2019-03-04T06:21:43.775Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Swift面向协议编程"><a href="#Swift面向协议编程" class="headerlink" title="Swift面向协议编程"></a>Swift面向协议编程</h2><p>所谓面向协议编程，就是使用<code>protocol</code>声明方法，然后使用<code>extension</code>提供默认的实现，只要需要使用到该方法的类遵循该<code>protocol</code>，就可以直接使用该<code>extension</code>的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">protocol animal &#123;</span><br><span class="line">    var food: String &#123;get&#125;</span><br><span class="line">    func eat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension animal &#123;</span><br><span class="line">    func eat() &#123;</span><br><span class="line">        print(&quot;food name is \(food)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Cat: animal &#123;</span><br><span class="line">    </span><br><span class="line">    var food: String = &quot;mouse&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Dog:animal &#123;</span><br><span class="line">    var food: String = &quot;cat&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cat = Cat()</span><br><span class="line">let dog = Dog()</span><br><span class="line">cat.eat()</span><br><span class="line">dog.eat()</span><br><span class="line"></span><br><span class="line">log:</span><br><span class="line">food name is mouse</span><br><span class="line">food name is cat</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="代码复用"><a href="#代码复用" class="headerlink" title="代码复用"></a>代码复用</h3><ul><li><strong>继承</strong>：会带来耦合。<ul><li>继承的代价：这并不是一个新颖的话题，自面向对象编程诞生之日起就饱受争议，我们经常要忍受着愈加繁杂和庞大的继承体系来获得代码的可重用性，而且随着继承层次的增加，代码的复杂性会加速增长，随之而来的bug也会越来越难以发现。这时我们可能需要依靠设计模式来找回我们的思路，然而大多数设计模式只能帮助你理顺你的代码结构，却在同时更加加深了你的代码的复杂度。</li></ul></li><li><strong><code>category</code>/<code>extension</code></strong>：会污染所有的类</li><li><strong>面向协议编程</strong>：<code>protocol</code>+<code>extension</code> 最大程度地减少了耦合</li></ul><h3 id="面向协议编程的好处"><a href="#面向协议编程的好处" class="headerlink" title="面向协议编程的好处"></a>面向协议编程的好处</h3><p>面向协议编程的好处在于，通过协议+扩展实现一个功能，能够定义所需要的充分必要条件，不多也不少。这样就<strong>最大程度减少了耦合</strong>。使用者可以像搭积木一样随意组合这些协议，写一个<code>class</code>或<code>struct</code>来完成复杂的功能。实际上，Swift的标准库几乎是<code>everything is starting out as a protocol</code>。</p><ul><li>代码没有增多，却更复⽤</li><li>⾯向协议(接⼝)，⽽不是实现，充分解耦 </li><li>静态类型检查帮助在编译时发现问题</li><li>写代码像搭积木，先设计接⼝，再逐⼀实现</li><li>依赖少，更容易调试</li></ul><h3 id="为什么说Swift是面向协议编程的语言？"><a href="#为什么说Swift是面向协议编程的语言？" class="headerlink" title="为什么说Swift是面向协议编程的语言？"></a>为什么说Swift是面向协议编程的语言？</h3><p>因为<code>Swift</code>里更推荐使用值类型变量（<code>struct</code>）而不是引用类型（<code>class</code>）的变量，<code>Swift</code>中许多常见的数据类型、字符串、集合类型，以及结构体和枚举都是值类型而非引用类型，值类型的变量在赋值时会自动进行一次低消耗的值拷贝，对比对象的<code>copy</code>要更加高效而且不存在线程安全问题。</p><h4 id="为什么需要struct"><a href="#为什么需要struct" class="headerlink" title="为什么需要struct"></a>为什么需要struct</h4><p><code>struct</code>和<code>class</code>的主要区别：</p><ul><li><code>struct</code>是值类型，而<code>class</code>是引用类型</li><li><code>struct</code>没有继承的功能，<code>class</code>有继承功能</li></ul><p>struct和class这两个基本层面的区别，体现了区别于Objective-C语言，swift语言带来了全新的天翻地覆的改变。</p><p>首先说第一点区别，从<code>swift</code>的更新和<code>struct</code>不断完善来看，苹果公司更加推荐使用<code>struct</code>来代替<code>class</code>，因为<code>struct</code>值类型和<code>class</code>引用类型这点区别，保证使用<code>struct</code>编码能写出更加安全可靠的代码。为什么这样说呢，<code>class</code>引用类型在赋值时是将变量指向了同一块内存地址，这在一个长时间的跨度上会带来一些意想不到的问题，试想一个简单的例子，<code>viewControllerA</code>持有一个<code>NSMutableArray</code>数组<code>mutalbeArray</code>，它包含100条<code>user</code>信息，此时将<code>mutableArray</code>赋值给<code>viewControllerB</code>，对于<code>viewControllerB</code>而言，它仅仅需要前10条<code>user</code>信息，所以它将<code>mutableArray</code>多余的信息删除了，这样一个脑残的操作导致了<code>viewControllerA</code>模块展示错误和潜在的逻辑错误。而使用<code>struct</code>值引用则不会出现这样的问题。</p><p>第二点区别，<code>struct</code>没有继承的功能，这是因为<code>swift</code>在本质上来说是面向协议(<code>Protocol Oriented</code>)的语言，<code>struct</code>没有也不需要继承的功能，为了实现某个功能，<code>struct</code>去服从并实现某个协议就即可，从一个较高的层次来看，<code>struct+protocol</code>是构成<code>swift</code>面向协议语言的两个基石。</p><h3 id="Swift标准库"><a href="#Swift标准库" class="headerlink" title="Swift标准库"></a>Swift标准库</h3><p>在 Swift 标准库里，包含55个 Protocol，102个 Struct，9个 Enums 和6个 Class，由此可见，苹果更推荐使用 Struct。</p><p>55个 Protocol 中大致可以分为三种类型：</p><ul><li>-Type：<ul><li>BooleanType</li><li>CollectionType</li><li>ErrorType</li></ul></li><li>-able:<ul><li>Comparable</li><li>Equatable</li><li>Hashable</li></ul></li><li>-Convertible<ul><li>ArrayLiteralConvertible</li><li>BooleanLiteralConvertible</li><li>CustomDebugStringConvertible</li></ul></li></ul><h3 id="协议的两种类型"><a href="#协议的两种类型" class="headerlink" title="协议的两种类型"></a>协议的两种类型</h3><p>普通的协议可以被当作类型约束使用，也可以当作独立的类型使用。带有关联类型或者 Self 约束的协议特殊一些：我们不能将它当作独立的类型来使用，而只能将它们用作类型约束。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Swift是一门支持多编程范式的语言，既支持面向对象编程，也支持面向协议编程，同时还支持函数式编程。在项目开发过程中，控制器和视图部分由于使用系统框架，应更多采用面向对象编程的方式；而模型或业务逻辑等自定义类型部分，则应优先考虑面向协议编程。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://blog.csdn.net/xuehongnizhao/article/details/55258066" target="_blank" rel="noopener">Swift面向协议编程（附代码）</a></p><p><a href="http://www.jianshu.com/p/4544b8837556" target="_blank" rel="noopener">谈谈Swift面向协议编程</a></p><p><a href="http://www.cocoachina.com/swift/20161121/18144.html" target="_blank" rel="noopener">从 Swift 的面向协议编程说开去</a></p><p><a href="http://www.cocoachina.com/swift/20150902/12824.html" target="_blank" rel="noopener">Swift面向协议编程初探</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Swift面向协议编程&quot;&gt;&lt;a href=&quot;#Swift面向协议编程&quot; class=&quot;headerlink&quot; title=&quot;Swift面向协议编程&quot;&gt;&lt;/a&gt;Swift面向协议编程&lt;/h2&gt;&lt;p&gt;所谓面向协议编程，就是使用&lt;code&gt;protocol&lt;/code&gt;声明方法，然后使用&lt;code&gt;extension&lt;/code&gt;提供默认的实现，只要需要使用到该方法的类遵循该&lt;code&gt;protocol&lt;/code&gt;，就可以直接使用该&lt;code&gt;extension&lt;/code&gt;的实现。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;protocol animal &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var food: String &amp;#123;get&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func eat()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;extension animal &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func eat() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&amp;quot;food name is \(food)&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct Cat: animal &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var food: String = &amp;quot;mouse&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct Dog:animal &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var food: String = &amp;quot;cat&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let cat = Cat()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let dog = Dog()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cat.eat()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dog.eat()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;log:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;food name is mouse&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;food name is cat&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="开发" scheme="https://fightingjoey.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Swift" scheme="https://fightingjoey.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift错误处理</title>
    <link href="https://fightingjoey.github.io/2017/11/11/%E5%BC%80%E5%8F%91/Swift%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <id>https://fightingjoey.github.io/2017/11/11/开发/Swift错误处理/</id>
    <published>2017-11-11T08:24:29.000Z</published>
    <updated>2018-09-27T02:10:15.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>任何代码都会发生错误，这些错误有些是可以补救的，有些则只能让程序崩溃。良好的错误处理能够让你的代码健壮性提高，提高程序的稳定性。</p><p><strong>本文的Swift版本：Swift 3</strong></p><h2 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective C"></a>Objective C</h2><h3 id="返回nil"><a href="#返回nil" class="headerlink" title="返回nil"></a><strong>返回nil</strong></h3><p>如果出错了，就返回空是Objective C中的一种常见的处理方式。因为在Objective C中，向nil发送消息是安全的。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    //如果初始化失败，会返回nil</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>断言指定了我们方法的上下文，如果断言不满足，则在Debug环境下会直接crash。</p><p>比如：AFNetworking中的<a href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLSessionManager.m#L419" target="_blank" rel="noopener">af_resume</a>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)af_resume &#123;</span><br><span class="line">    NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);</span><br><span class="line">    NSURLSessionTaskState state = [self state];</span><br><span class="line">    [self af_resume];</span><br><span class="line">    </span><br><span class="line">    if (state != NSURLSessionTaskStateRunning) &#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="返回状态码"><a href="#返回状态码" class="headerlink" title="返回状态码"></a><strong>返回状态码</strong></h3><p>返回状态码和全局错误信息往往是在一起使用的。这种错误的处理方式常见于用Objective C来封装C的代码，或者纯C的方法。比如sqlite中的错误处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int result = sqlite3_open(dbPath,&amp;_db );</span><br><span class="line">if(result != SQLITE_OK) &#123;//如果出错</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又比如，Data写入到文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL succeed = [currentData writeToFile:path atomically:YES];</span><br></pre></td></tr></table></figure><h3 id="NSError"><a href="#NSError" class="headerlink" title="NSError"></a><strong>NSError</strong></h3><blockquote><p><font color="red"><strong>NSError是Cocoa中推荐的错误处理方式</strong></font>。<br>使用NSError来处理错误的例子遍布整个CocoaTouch框架。<br>比如：NSFileManager</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSFileManager * fm  = [NSFileManager defaultManager];</span><br><span class="line">NSError * error;</span><br><span class="line">[fm removeItemAtPath:path error:&amp;error];</span><br></pre></td></tr></table></figure><p>又比如，NSURLSession通过NSError来传递错误信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[NSURLSession sharedSession] dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">        </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>一个NSError包括了错误的详细信息：主要有以下几个信息</p><ul><li>code 错误的状态码</li><li>domain 错误的域</li><li>userInfo 错误的详细信息</li></ul><p>比如，常见的NSURLErrorDomain，也就是网络请求失败：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSURLErrorCancelled = -999,</span><br><span class="line">NSURLErrorBadURL = -1000,</span><br><span class="line">NSURLErrorTimedOut = -1001,</span><br><span class="line">NSURLErrorUnsupportedURL = -1002,</span><br><span class="line">NSURLErrorCannotFindHost = -1003,</span><br><span class="line">//....</span><br></pre></td></tr></table></figure><h3 id="NSException"><a href="#NSException" class="headerlink" title="NSException"></a><strong>NSException</strong></h3><p>NSException是类似其他语言中的异常，你可以通过try-catch等方式捕获异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@try &#123;</span><br><span class="line">    //Code that can potentially throw an exception</span><br><span class="line">&#125; @catch (NSException *exception) &#123;</span><br><span class="line">    //Handle an exception thrown in the @try block</span><br><span class="line">&#125; @finally &#123;</span><br><span class="line">    //Code that gets executed whether or not an exception is thrown</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，你也可以自己抛出一个异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSException raise:@&quot;ExceptionName&quot; format:@&quot;Contents&quot;];</span><br></pre></td></tr></table></figure><blockquote><ul><li><font color="red">在Objective C中，通常只有当程序出错，无法继续执行的时候，我们才会主动抛出一个异常。</font></li><li>Objective C的异常处理的效率很低，通常不用来做错误处理,而且Objective C也没有类似的throw关键字来表明一个方法会抛出异常，编码起来很难判断是否需要try-cathe。</li></ul></blockquote><hr><h2 id="Swift中的错误处理"><a href="#Swift中的错误处理" class="headerlink" title="Swift中的错误处理"></a>Swift中的错误处理</h2><blockquote><p>Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime.</p></blockquote><p>Swift提供了一套完整的错误抛出-捕获-处理机制。Swift采用<code>Error</code>协议来表示错误类型，通过do-try-catch的方式来处理可能会抛出异常的代码。</p><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>可选值表示一个值要么有值，要么是nil。在Swift中，Optional是用enum写的，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum Optional&lt;Wrapped&gt; : ExpressibleByNilLiteral &#123;</span><br><span class="line">    case none</span><br><span class="line">    case some(Wrapped)</span><br><span class="line"> //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当发生错误的时候，返回一个可选值是常见的处理方式。但是，这种方式的有一个很明显的缺点：</p><blockquote><p>调用者不清楚为什么失败，也就不好进行相关的处理。</p></blockquote><h3 id="Error协议与throws"><a href="#Error协议与throws" class="headerlink" title="Error协议与throws"></a><strong>Error协议与throws</strong></h3><p><code>Error</code>是一个空的协议，用来表示错误类型。<code>NSError</code>和<code>CFError</code>都遵循了这个协议。</p><p>throws关键字表明这个方法会抛出错误，方法调用者需要处理错误。</p><p>在Swfit中，枚举是一个特别适合用来处理Error的数据类型。我们首先定义一个类Person表示人</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum Sex&#123;</span><br><span class="line">    case male</span><br><span class="line">    case female</span><br><span class="line">&#125;</span><br><span class="line">class Person&#123;</span><br><span class="line">    let sex:Sex</span><br><span class="line">    var money:CGFloat</span><br><span class="line">    init(sex:Sex ,money:CGFloat) &#123;</span><br><span class="line">        self.sex = sex</span><br><span class="line">        self.money = money</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person可以结婚，结婚的时候会发生一些错误，比如钱不够，比如性别不对，用枚举来表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum MarryError : Error&#123;</span><br><span class="line">    case lackMoney</span><br><span class="line">    case wrongSex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，方法的实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extension Person&#123;</span><br><span class="line">    func marry(with another: Person) throws -&gt; Bool&#123;</span><br><span class="line">        guard self.sex != another.sex else&#123;</span><br><span class="line">            throw MarryError.wrongSex</span><br><span class="line">        &#125;</span><br><span class="line">        guard self.money + another.money &gt; 100000 else &#123;</span><br><span class="line">            throw MarryError.lackMoney</span><br><span class="line">        &#125;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个带有throws关键字的函数，调用的时候有两种方式选择：</p><ul><li><strong>使用 do-try-catch 代码块</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let tom = Person(sex: .male, money: 100000)</span><br><span class="line">let jack = Person(sex: .male, money: 100000)</span><br><span class="line">do&#123;</span><br><span class="line">    try tom.marry(with: jack)</span><br><span class="line">&#125;catch MarryError.wrongSex &#123;</span><br><span class="line">    print(&quot;Two Person have same sex&quot;)</span><br><span class="line">&#125;catch MarryError.lackMoney&#123;</span><br><span class="line">    print(&quot;Oh, they do not have enough moeny&quot;)</span><br><span class="line">&#125;catch let error&#123;</span><br><span class="line">    print(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，如果不需要区分每一个Error，也可以这么调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">    try tom.marry(with: jack)</span><br><span class="line">&#125;catch let error&#123;</span><br><span class="line">    print(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用 try?，对于有返回值的throws函数，使用try?会把结果转换为可选值。</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let tom = Person(sex: .male, money: 100000)</span><br><span class="line">let jack = Person(sex: .male, money: 100000)</span><br><span class="line"></span><br><span class="line">if let result = try? tom.marry(with: jack)&#123;//成功</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line">    print(&quot;Error happen&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="defer关键字"><a href="#defer关键字" class="headerlink" title="defer关键字"></a><strong>defer关键字</strong></h3><p>defer关键字用来处理类似Ojective C中@try-@catch-@finally中，@finally的作用。<br>比如，我们打开文件，如果抛出错误的话，我们总希望关闭这个文件句柄。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func contents(of filePath:String) throws -&gt; String&#123;</span><br><span class="line">    let file = open(filePath,O_RDWR)</span><br><span class="line">    defer &#123;</span><br><span class="line">        close(file)</span><br><span class="line">    &#125;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>defer代码块的内容在退出作用域之前会被执行</p></blockquote><p>关于defer，有两点需要注意</p><ul><li>多个defer会按照逆序的方式执行。</li><li>当你的程序遇到严重错误，比如fatalError,或者强制解析nil，或者segfaults的时候，defer的代码块并不会执行。</li></ul><h3 id="rethrow"><a href="#rethrow" class="headerlink" title="rethrow"></a><strong>rethrow</strong></h3><p>rethrow关键字在高阶函数中比较常见，所谓高阶函数，就是一个函数的参数或者返回值是函数类型。</p><p>最常见的比如，<code>Sequence</code>协议<code>map</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let array = [1,2,3]</span><br><span class="line">let result = array.map&#123;$0 * 2&#125;</span><br></pre></td></tr></table></figure><p>由于map函数传入的是一个闭包，这个闭包可能会抛出错误。由参数抛出的错误最后会向上传递给map函数。</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum MapError : Error&#123;</span><br><span class="line">    case invalid</span><br><span class="line">&#125;</span><br><span class="line">func customMapper(input:Int) throws -&gt; Int&#123;</span><br><span class="line">    if input &lt; 10&#123;</span><br><span class="line">        throw MapError.invalid</span><br><span class="line">    &#125;</span><br><span class="line">    return input + 1</span><br><span class="line">&#125;</span><br><span class="line">let array = [1,2,3]</span><br><span class="line">let result = array.map(customMapper)</span><br></pre></td></tr></table></figure><blockquote><p>这样是编译不通过的。</p></blockquote><p>调用的时候需要：按照上文提到的throws关键字的路子来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    let result = try array.map(customMapper)</span><br><span class="line">&#125; catch let error&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，这就是rethrows关键字的精髓所在</p><blockquote><p>rethrows 关键字表示当参数闭包标记为throws的时候，函数本身为throws。如果参数闭包不会抛出错误，则函数也不会。</p></blockquote><p>通过这个关键字，你不必每次都进行try-catch</p><h3 id="Result类型"><a href="#Result类型" class="headerlink" title="Result类型"></a>Result类型</h3><p>我们知道，一个函数执行要么成功，要么失败。成功的时候我们希望返回数据，失败的时候我们希望得到错误信息，这就是Result类型，一个典型的Result类型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Result&lt;T&gt;&#123;</span><br><span class="line">    case success(T)</span><br><span class="line">    case failure(error:Error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Result类型，不再需要可选值或者do-try-catch来包裹你的代码。</p><p>我们用Result类型对上述marry函数进行重写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extension Person&#123;</span><br><span class="line">    func marry(with another: Person)  -&gt; Result&lt;Bool&gt;&#123;</span><br><span class="line">        guard self.sex != another.sex else&#123;</span><br><span class="line">            return .failure(error: MarryError.wrongSex)</span><br><span class="line">        &#125;</span><br><span class="line">        guard self.money + another.money &gt; 100000 else &#123;</span><br><span class="line">            return .failure(error: MarryError.lackMoney)</span><br><span class="line">        &#125;</span><br><span class="line">        return .success(true)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，这么调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let tom = Person(sex: .male, money: 100000)</span><br><span class="line">let jack = Person(sex: .male, money: 100000)</span><br><span class="line">let result = tom.marry(with: jack)</span><br><span class="line">switch result &#123;</span><br><span class="line">case let .success(value):</span><br><span class="line">    print(value)</span><br><span class="line">case let .failure(error):</span><br><span class="line">    print(error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Result链"><a href="#Result链" class="headerlink" title="Result链"></a><strong>Result链</strong></h4><p>Swift中有可选链，来处理多个可选值的连续调用。同样的，我们也可以为Result类型来添加链式调用：</p><ul><li>如果上一个调用结果是.success, 则继续调用下一个</li><li>如果上一个调用结果是.failure, 则传递failure给下一个</li></ul><p>我们可以用extension来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extension Result&#123;</span><br><span class="line">    func flatMap&lt;V&gt;(transform:(T) throws -&gt; (V)) rethrows -&gt; Result&lt;V&gt;&#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case let .failure(error):</span><br><span class="line">            return .failure(error: error)</span><br><span class="line">        </span><br><span class="line">        case let .success(data):</span><br><span class="line">            return .success(try transform(data))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，你就可以这么调用了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resut.flatMap(&#123;//转换1&#125;).flatMap(//转换2)...</span><br></pre></td></tr></table></figure><p>一旦失败，中间有一次flatMap转换失败，则之后的转换逻辑都不会执行</p><blockquote><p>进阶：Result类型在Swift版本的Promise中大行其道，可以参见<a href="https://github.com/mxcl/PromiseKit/blob/master/Sources/Promise.swift" target="_blank" rel="noopener">PromiseKit</a>的源码，promise让异步处理变得优雅。</p></blockquote><h3 id="assert-precondition"><a href="#assert-precondition" class="headerlink" title="assert/precondition"></a><strong>assert/precondition</strong></h3><p>在本文最初的的地方降到了Objective C的断言，同样Swift也有断言支持。在Swfit中，断言是一个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func assert(_ condition: @autoclosure () -&gt; Bool, </span><br><span class="line">  _ message: @autoclosure () -&gt; String = default, </span><br><span class="line">       file: StaticString = #file, </span><br><span class="line">       line: UInt = #line)</span><br></pre></td></tr></table></figure><p>断言仅在Debug模式下进行检查，帮助开发者发现代码中的问题。</p><p>如果需要在Relase模式下也进行检查，则使用<code>precondition</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func precondition(_ condition: @autoclosure () -&gt; Bool, </span><br><span class="line">  _ message: @autoclosure () -&gt; String = default, </span><br><span class="line">       file: StaticString = #file, </span><br><span class="line">       line: UInt = #line)</span><br></pre></td></tr></table></figure><h3 id="桥接到Objective-C"><a href="#桥接到Objective-C" class="headerlink" title="桥接到Objective C"></a><strong>桥接到Objective C</strong></h3><p>对于如下使用NSError来处理错误的的Objective 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//NSFileManager</span><br><span class="line">- (BOOL)removeItemAtURL:(NSURL *)URL error:(NSError * _Nullable *)error;</span><br></pre></td></tr></table></figure><p>在Swift中会被自动的转换成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func removeItem(at URL: URL) throws</span><br></pre></td></tr></table></figure><p>但是，纯Swfit的Error桥接的Objective C的时候，会有一些问题。因为NSError需要 <code>domain</code>和<code>code</code>等详细信息。</p><p>我们可以让Swift的Error实现CustomNSError协议，来提供这些需要的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">enum MarryError : Error&#123;</span><br><span class="line">    case lackMoney</span><br><span class="line">    case wrongSex</span><br><span class="line">&#125;</span><br><span class="line">extension MarryError : CustomNSError&#123;</span><br><span class="line">    static let errorDomain = &quot;com.person.marryError&quot;</span><br><span class="line">    var erroCode:Int&#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .lackMoney:</span><br><span class="line">            return -100001</span><br><span class="line">        case .wrongSex:</span><br><span class="line">            return -100002</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var errorUserInfo:[String:Any]&#123;</span><br><span class="line">        return [:]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关的，还有两个协议<code>LocalizedError</code>和<code>RecoverableError</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;任何代码都会发生错误，这些错误有些是可以补救的，有些则只能让程序崩溃。良好的错误处理能够让你的代码健壮性提高，提高程序的稳定性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文的Swift版本：Swift 3&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;Objective-C&quot;&gt;&lt;a href=&quot;#Objective-C&quot; class=&quot;headerlink&quot; title=&quot;Objective C&quot;&gt;&lt;/a&gt;Objective C&lt;/h2&gt;&lt;h3 id=&quot;返回nil&quot;&gt;&lt;a href=&quot;#返回nil&quot; class=&quot;headerlink&quot; title=&quot;返回nil&quot;&gt;&lt;/a&gt;&lt;strong&gt;返回nil&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;如果出错了，就返回空是Objective C中的一种常见的处理方式。因为在Objective C中，向nil发送消息是安全的。比如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (instancetype)init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self = [super init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (self) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //如果初始化失败，会返回nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return self;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;断言&quot;&gt;&lt;a href=&quot;#断言&quot; class=&quot;headerlink&quot; title=&quot;断言&quot;&gt;&lt;/a&gt;断言&lt;/h3&gt;&lt;p&gt;断言指定了我们方法的上下文，如果断言不满足，则在Debug环境下会直接crash。&lt;/p&gt;
&lt;p&gt;比如：AFNetworking中的&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLSessionManager.m#L419&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;af_resume&lt;/a&gt;方法&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)af_resume &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSAssert([self respondsToSelector:@selector(state)], @&amp;quot;Does not respond to state&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSURLSessionTaskState state = [self state];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self af_resume];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (state != NSURLSessionTaskStateRunning) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="开发" scheme="https://fightingjoey.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Swift" scheme="https://fightingjoey.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS多线程 Swift4 GCD深入解析</title>
    <link href="https://fightingjoey.github.io/2017/11/07/%E5%BC%80%E5%8F%91/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
    <id>https://fightingjoey.github.io/2017/11/07/开发/iOS多线程深入解析/</id>
    <published>2017-11-07T08:07:17.000Z</published>
    <updated>2018-09-27T02:09:32.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS多线程深入解析"><a href="#iOS多线程深入解析" class="headerlink" title="iOS多线程深入解析"></a>iOS多线程深入解析</h1><h2 id="必要的概念"><a href="#必要的概念" class="headerlink" title="必要的概念"></a>必要的概念</h2><h3 id="进程-线程"><a href="#进程-线程" class="headerlink" title="进程/线程"></a>进程/线程</h3><p><strong>进程</strong>：进程指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。</p><p><strong>线程</strong>：线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行。</p><p><strong>操作系统引入进程的目的</strong>：为了使多个程序能并发执行，以提高资源的利用率和系统的吞吐量。</p><p><strong>操作系统引入线程的目的</strong>：在操作系统中再引入线程，则是为了减少程序在并发执行时所付出的时空开销，使<code>OS</code>具有更好的并发性。多线程技术可以提高程序的执行效率。</p><blockquote><p>在引入线程的OS中，通常把进程作为资源分配的基本单位，而把线程作为独立运行和独立调度的基本单位。</p></blockquote><a id="more"></a><h3 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h3><p><strong>同步</strong>：多个任务情况下，一个任务A执行结束，才可以执行另一个任务B。</p><p><strong>异步</strong>：多个任务情况下，一个任务A正在执行，同时可以执行另一个任务B。任务B不用等待任务A结束才执行。存在多条线程。</p><h3 id="并行-并发"><a href="#并行-并发" class="headerlink" title="并行/并发"></a>并行/并发</h3><p><strong>并行</strong>：指两个或多个事件在同一时刻发生。多核CUP同时开启多条线程供多个任务同时执行，互不干扰。</p><p><strong>并发</strong>：指两个或多个事件在同一时间间隔内发生。可以在某条线程和其他线程之间反复多次进行上下文切换，看上去就好像一个CPU能够并且执行多个线程一样。其实是伪异步。</p><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>在1个进程中，线程往往不是孤立存在的，多个线程之间需要经常进行通信</p><p><strong>线程间通信的体现：</strong></p><ul><li>1个线程传递数据给另1个线程</li><li>在1个线程中执行完特定任务后，转到另1个线程继续执行任务</li></ul><h2 id="多线程概念"><a href="#多线程概念" class="headerlink" title="多线程概念"></a>多线程概念</h2><p>多线程是指在软件或硬件上实现多个线程并发执行的技术。通俗讲就是在同步或异步的情况下，开辟新线程，进行线程间的切换，以及对线程进行合理的调度，做到优化提升程序性能的目的。</p><h3 id="多线程的优点"><a href="#多线程的优点" class="headerlink" title="多线程的优点"></a>多线程的优点</h3><ul><li>能适当提高程序的执行效率 </li><li>能适当提高资源利用率（CPU、内存利用率）</li><li>避免在处理耗时任务时造成主线程阻塞</li></ul><h3 id="多线程的缺点"><a href="#多线程的缺点" class="headerlink" title="多线程的缺点"></a>多线程的缺点</h3><ul><li>开启线程需要占用一定的内存空间，如果开启大量的线程，会占用大量的内存空间，降低程序的性能</li><li>线程越多，CPU在调度线程上的开销就越大 </li><li>可能会导致多个线程相互持续等待[死锁]</li><li>程序设计更加复杂：比如线程之间的通信、多线程之间的数据竞争</li></ul><h2 id="GCD（Grand-Central-Dispatch）"><a href="#GCD（Grand-Central-Dispatch）" class="headerlink" title="GCD（Grand Central Dispatch）"></a>GCD（Grand Central Dispatch）</h2><p><code>Dispatch</code>会自动的根据<code>CPU</code>的使用情况，创建线程来执行任务，并且自动的运行到多核上，提高程序的运行效率。对于开发者来说，在<code>GCD</code>层面是没有线程的概念的，只有队列（<code>queue</code>）。任务都是以<code>block</code>的方式提交到队列上，然后<code>GCD</code>会自动的创建线程池去执行这些任务。</p><h3 id="GCD的优点："><a href="#GCD的优点：" class="headerlink" title="GCD的优点："></a>GCD的优点：</h3><ul><li>GCD是苹果公司为多核的并行运算提出的解决方案 </li><li>GCD会自动利用更多的CPU内核（比如双核、四核） </li><li>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程） </li><li>程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码</li></ul><h3 id="GCD中有两个核心概念"><a href="#GCD中有两个核心概念" class="headerlink" title="GCD中有两个核心概念"></a>GCD中有两个核心概念</h3><p><strong>任务 block</strong>：执行什么操作 </p><p><strong>队列 queue</strong>：用来存放任务</p><h3 id="GCD的使用就两个步骤"><a href="#GCD的使用就两个步骤" class="headerlink" title="GCD的使用就两个步骤"></a>GCD的使用就两个步骤</h3><ol><li>定制任务，确定想做的事情</li><li>将任务添加到队列中，<code>GCD</code>会自动将队列中的任务取出，放到对应的线程中执行。任务的取出遵循队列的<code>FIFO</code>原则：先进先出，后进后出。</li></ol><h3 id="GCD中有两个执行任务的函数"><a href="#GCD中有两个执行任务的函数" class="headerlink" title="GCD中有两个执行任务的函数"></a>GCD中有两个执行任务的函数</h3><ul><li><p>同步执行任务（<strong>sync</strong>）</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure></li></ul><pre><code>&gt; 同步任务会阻塞当前线程，然后把`Block`中的任务放到指定的队列中执行，只有等到`Block`中的任务完成后才会让当前线程继续往下运行。&gt; `sync`是一个强大但是容易被忽视的函数。使用`sync`，可以方便的进行线程间同步。但是，有一点要注意，`sync`容易造成死锁。</code></pre><ul><li><p>异步执行任务（<strong>async</strong>）</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</span><br></pre></td></tr></table></figure></li></ul><pre><code>&gt; 异步任务会再开辟一个线程，当前线程继续往下走，新线程去执行`block`里的任务。</code></pre><h3 id="GCD的队列可以分为两大类型"><a href="#GCD的队列可以分为两大类型" class="headerlink" title="GCD的队列可以分为两大类型"></a>GCD的队列可以分为两大类型</h3><ul><li><p><strong>并行队列（Concurrent Dispatch Queue）</strong>：</p><ul><li>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务） </li><li><p>并行功能只有在异步（dispatch_async）函数下才有效</p><blockquote><p>放到并行队列的任务，如果是异步执行，<code>GCD</code>也会<code>FIFO</code>的取出来，但不同的是，它取出来一个就会放到别的线程，然后再取出来一个又放到另一个的线程。这样由于取的动作很快，忽略不计，看起来，所有的任务都是一起执行的。不过需要注意，<code>GCD</code>会根据系统资源控制并行的数量，所以如果任务很多，它并不会让所有任务同时执行。</p></blockquote></li></ul></li></ul><ul><li><p><strong>串行队列（Serial Dispatch Queue）</strong>：</p><p>  让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）</p><p>  |   |同步执行|异步执行|<br>  |:–|:–|:–|<br>  |串行队列|当前线程，一个一个执行|其他线程，一个一个执行|<br>  |并发队列|当前线程，一个一个执行|开很多线程，一起执行|</p></li></ul><h1 id="Swift4-GCD-使用"><a href="#Swift4-GCD-使用" class="headerlink" title="Swift4 GCD 使用"></a>Swift4 GCD 使用</h1><h2 id="DispatchQueue"><a href="#DispatchQueue" class="headerlink" title="DispatchQueue"></a>DispatchQueue</h2><p>最简单的，可以按照以下方式初始化一个队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这里的名字能够方便开发者进行Debug</span><br><span class="line">let queue = DispatchQueue(label: &quot;com.geselle.demoQueue&quot;)</span><br></pre></td></tr></table></figure><p>这样初始化的队列是一个默认配置的队列，也可以显式的指明对列的其他属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let label = &quot;com.leo.demoQueue&quot;</span><br><span class="line">let qos =  DispatchQoS.default</span><br><span class="line">let attributes = DispatchQueue.Attributes.concurrent</span><br><span class="line">let autoreleaseFrequency = DispatchQueue.AutoreleaseFrequency.never</span><br><span class="line">let queue = DispatchQueue(label: label, qos: qos, attributes: attributes, autoreleaseFrequency: autoreleaseFrequency, target: nil)</span><br></pre></td></tr></table></figure><p>这里，我们来一个参数分析他们的作用</p><ul><li><code>label</code>： 队列的标识符，方便调试</li><li><code>qos</code>： 队列的<code>quality of service</code>。用来指明队列的“重要性”，后文会详细讲到。</li><li><code>attributes</code>： 队列的属性。类型是<code>DispatchQueue.Attributes</code>,是一个结构体，遵循了协议<code>OptionSet</code>。意味着你可以这样传入第一个参数<code>[.option1,.option2]</code>。<ul><li>默认：队列是串行的。</li><li><code>.concurrent</code>：队列为并行的。</li><li><code>.initiallyInactive</code>：则队列任务不会自动执行，需要开发者手动触发。</li></ul></li><li><code>autoreleaseFrequency</code>： 顾名思义，自动释放频率。有些队列是会在执行完任务后自动释放的，有些比如<code>Timer</code>等是不会自动释放的，是需要手动释放。</li></ul><h3 id="队列分类"><a href="#队列分类" class="headerlink" title="队列分类"></a>队列分类</h3><ul><li>系统创建的队列<ul><li>主队列（对应主线程）</li><li>全局队列</li></ul></li><li>用户创建的队列</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 获取系统队列</span><br><span class="line">let mainQueue = DispatchQueue.main</span><br><span class="line">let globalQueue = DispatchQueue.global()</span><br><span class="line">let globalQueueWithQos = DispatchQueue.global(qos: .userInitiated)</span><br><span class="line"></span><br><span class="line">// 创建串行队列</span><br><span class="line">let serialQueue = DispatchQueue(label: &quot;com.geselle.serialQueue&quot;)</span><br><span class="line"></span><br><span class="line">// 创建并行队列</span><br><span class="line">let concurrentQueue = DispatchQueue(label: &quot;com.geselle.concurrentQueue&quot;,attributes:.concurrent)</span><br><span class="line"></span><br><span class="line">// 创建并行队列，并手动触发</span><br><span class="line">let concurrentQueue2 = DispatchQueue(label:&quot;com.geselle.concurrentQueue2&quot;, qos: .utility,attributes[.concurrent,.initiallyInactive]) </span><br><span class="line">//手动触发</span><br><span class="line">if let queue = inactiveQueue &#123;</span><br><span class="line">queue.activate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="suspend-resume"><a href="#suspend-resume" class="headerlink" title="suspend / resume"></a>suspend / resume</h3><p><strong>Suspend</strong>可以挂起一个线程，就是把这个线程暂停了，它占着资源，但不运行。</p><p><strong>Resume</strong>可以继续挂起的线程，让这个线程继续执行下去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">concurrentQueue.resume()</span><br><span class="line">concurrentQueue.suspend(）</span><br></pre></td></tr></table></figure><h2 id="QoS（quality-of-service）"><a href="#QoS（quality-of-service）" class="headerlink" title="QoS（quality of service）"></a>QoS（quality of service）</h2><p><code>QoS</code>的全称是<code>quality of service</code>。在<code>Swift 3</code>中，它是一个结构体，用来制定队列或者任务的<strong>重要性</strong>。</p><blockquote><p>何为重要性呢？就是当资源有限的时候，优先执行哪些任务。这些优先级包括 CPU 时间，数据 IO 等等，也包括 ipad muiti tasking（两个App同时在前台运行）。</p></blockquote><h3 id="通常使用QoS为以下四种，从上到下优先级依次降低。"><a href="#通常使用QoS为以下四种，从上到下优先级依次降低。" class="headerlink" title="通常使用QoS为以下四种，从上到下优先级依次降低。"></a>通常使用<code>QoS</code>为以下四种，从上到下优先级依次降低。</h3><ul><li><code>User Interactive</code>： 和用户交互相关，比如动画等等优先级最高。比如用户连续拖拽的计算</li><li><code>User Initiated</code>： 需要立刻的结果，比如<code>push</code>一个<code>ViewController</code>之前的数据计算</li><li><code>Utility</code>： 可以执行很长时间，再通知用户结果。比如下载一个文件，给用户下载进度。</li><li><code>Background</code>： 用户不可见，比如在后台存储大量数据</li></ul><h3 id="通常，你需要问自己以下几个问题"><a href="#通常，你需要问自己以下几个问题" class="headerlink" title="通常，你需要问自己以下几个问题"></a>通常，你需要问自己以下几个问题</h3><ul><li>这个任务是用户可见的吗？</li><li>这个任务和用户交互有关吗？</li><li>这个任务的执行时间有多少？</li><li>这个任务的最终结果和UI有关系吗？</li></ul><h3 id="在GCD中，指定QoS有以下两种方式"><a href="#在GCD中，指定QoS有以下两种方式" class="headerlink" title="在GCD中，指定QoS有以下两种方式"></a>在GCD中，指定QoS有以下两种方式</h3><p>方式一：创建一个指定<code>QoS</code>的<code>queue</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let backgroundQueue = DispatchQueue(label: &quot;com.geselle.backgroundQueue&quot;, qos: .background)</span><br><span class="line">backgroundQueue.async &#123;</span><br><span class="line">    //在QoS为background下运行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：在提交<code>block</code>的时候，指定<code>QoS</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">queue.async(qos: .background) &#123;</span><br><span class="line">    //在QoS为background下运行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DispatchGroup"><a href="#DispatchGroup" class="headerlink" title="DispatchGroup"></a>DispatchGroup</h2><p><a href="https://developer.apple.com/documentation/dispatch/dispatchgroup" target="_blank" rel="noopener">DispatchGroup</a>用来管理一组任务的执行，然后监听任务都完成的事件。比如，多个网络请求同时发出去，等网络请求都完成后<code>reload UI</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let group = DispatchGroup()</span><br><span class="line"></span><br><span class="line">let queueBook = DispatchQueue(label: &quot;book&quot;)</span><br><span class="line">print(&quot;start networkTask task 1&quot;)</span><br><span class="line">queueBook.async(group: group) &#123;</span><br><span class="line">    sleep(2)</span><br><span class="line">    print(&quot;End networkTask task 1&quot;)</span><br><span class="line">&#125;</span><br><span class="line">let queueVideo = DispatchQueue(label: &quot;video&quot;)</span><br><span class="line">print(&quot;start networkTask task 2&quot;)</span><br><span class="line">queueVideo.async(group: group) &#123;</span><br><span class="line">    sleep(2)</span><br><span class="line">    print(&quot;End networkTask task 2&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group.notify(queue: DispatchQueue.main) &#123;</span><br><span class="line">    print(&quot;all task done&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>group.notify</code>会等<code>group</code>里的所有任务全部完成以后才会执行（<strong>不管是同步任务还是异步任务</strong>）。</p><h3 id="Group-enter-Group-leave"><a href="#Group-enter-Group-leave" class="headerlink" title="Group.enter / Group.leave"></a>Group.enter / Group.leave</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> 首先写一个函数，模拟异步网络请求</span><br><span class="line"> </span><br><span class="line"> 这个函数有三个参数</span><br><span class="line"> * label 表示id</span><br><span class="line"> * cost 表示时间消耗</span><br><span class="line"> * complete 表示任务完成后的回调</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line">public func networkTask(label:String, cost:UInt32, complete:@escaping ()-&gt;())&#123;</span><br><span class="line">    print(&quot;Start network Task task%@&quot;,label)</span><br><span class="line">    DispatchQueue.global().async &#123;</span><br><span class="line">        sleep(cost)</span><br><span class="line">        print(&quot;End networkTask task%@&quot;,label)</span><br><span class="line">        DispatchQueue.main.async &#123;</span><br><span class="line">            complete()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 我们模拟两个耗时2秒和4秒的网络请求</span><br><span class="line"></span><br><span class="line">print(&quot;Group created&quot;)</span><br><span class="line">let group = DispatchGroup()</span><br><span class="line">group.enter()</span><br><span class="line">networkTask(label: &quot;1&quot;, cost: 2, complete: &#123;</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">group.enter()</span><br><span class="line">networkTask(label: &quot;2&quot;, cost: 2, complete: &#123;</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">group.wait(timeout: .now() + .seconds(4))</span><br><span class="line"></span><br><span class="line">group.notify(queue: .main, execute:&#123;</span><br><span class="line">    print(&quot;All network is done&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Group-wait"><a href="#Group-wait" class="headerlink" title="Group.wait"></a>Group.wait</h3><p><code>DispatchGroup</code>支持阻塞当前线程，等待执行结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//在这个点，等待三秒钟</span><br><span class="line">group.wait(timeout:.now() + .seconds(3))</span><br></pre></td></tr></table></figure><h2 id="DispatchWorkItem"><a href="#DispatchWorkItem" class="headerlink" title="DispatchWorkItem"></a>DispatchWorkItem</h2><p>上文提到的方式，我们都是以<code>block（</code>或者叫闭包）的形式提交任务。<code>DispatchWorkItem</code>则把任务封装成了一个对象。</p><p>比如，你可以这么使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let item = DispatchWorkItem &#123; </span><br><span class="line">    //任务</span><br><span class="line">&#125;</span><br><span class="line">DispatchQueue.global().async(execute: item)</span><br></pre></td></tr></table></figure><p>也可以在初始化的时候指定更多的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let item = DispatchWorkItem(qos: .userInitiated, flags: [.enforceQoS,.assignCurrentContext]) &#123; </span><br><span class="line">    //任务</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* 第一个参数表示 QoS。</span><br><span class="line">* 第二个参数类型为 DispatchWorkItemFlags。指定这个任务的配饰信息</span><br><span class="line">* 第三个参数则是实际的任务 block</span><br></pre></td></tr></table></figure><p><code>DispatchWorkItemFlags</code>的参数分为两组</p><ul><li><p>执行情况</p><ul><li>barrier</li><li>detached </li><li>assignCurrentContext</li></ul></li><li><p>QoS覆盖信息</p><ul><li>noQoS //没有 QoS</li><li>inheritQoS //继承 Queue 的 QoS</li><li>enforceQoS //自己的 QoS 覆盖 Queue</li></ul></li></ul><h2 id="after（延迟执行）"><a href="#after（延迟执行）" class="headerlink" title="after（延迟执行）"></a>after（延迟执行）</h2><p><code>GCD</code>可以通过<code>asyncAfter</code>来提交一个<strong>延迟执行的任务</strong></p><p>比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let deadline = DispatchTime.now() + 2.0</span><br><span class="line">print(&quot;Start&quot;)</span><br><span class="line">DispatchQueue.global().asyncAfter(deadline: deadline) &#123; </span><br><span class="line">    print(&quot;End&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>延迟执行</strong>还支持一种模式<code>DispatchWallTime</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let walltime = DispatchWallTime.now() + 2.0</span><br><span class="line">print(&quot;Start&quot;)</span><br><span class="line">DispatchQueue.global().asyncAfter(wallDeadline: walltime) &#123; </span><br><span class="line">    print(&quot;End&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的区别就是</p><ul><li><code>DispatchTime</code> 的精度是纳秒</li><li><code>DispatchWallTime</code> 的精度是微秒</li></ul><h2 id="Synchronization-同步"><a href="#Synchronization-同步" class="headerlink" title="Synchronization 同步"></a>Synchronization 同步</h2><p>通常，在多线程同时会对一个变量(比如<code>NSMutableArray</code>)进行读写的时候，我们需要考虑到线程的同步。举个例子：比如线程一在对<code>NSMutableArray</code>进行<code>addObject</code>的时候，线程二如果也想<code>addObject</code>,那么它必须等到线程一执行完毕后才可以执行。</p><p>实现这种同步有很多种机制</p><h3 id="NSLock-互斥锁"><a href="#NSLock-互斥锁" class="headerlink" title="NSLock 互斥锁"></a>NSLock 互斥锁</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let lock = NSLock()</span><br><span class="line">lock.lock()</span><br><span class="line">//Do something</span><br><span class="line">lock.unlock()</span><br></pre></td></tr></table></figure><p>使用锁有一个不好的地方就是：<code>lock</code>和<code>unlock</code>要配对使用，不然极容易锁住线程，没有释放掉。</p><h3 id="sync-同步函数"><a href="#sync-同步函数" class="headerlink" title="sync 同步函数"></a>sync 同步函数</h3><p>使用<code>GCD</code>，队列同步有另外一种方式<code>- sync</code>，讲属性的访问同步到一个<code>queue</code>上去，就能保证在多线程同时访问的时候，线程安全。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyData&#123;</span><br><span class="line">    private var privateData:Int = 0</span><br><span class="line">    private let dataQueue = DispatchQueue(label: &quot;com.leo.dataQueue&quot;)</span><br><span class="line">    var data:Int&#123;</span><br><span class="line">        get&#123;</span><br><span class="line">            return dataQueue.sync&#123; privateData &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        set&#123;</span><br><span class="line">            dataQueue.sync &#123; privateData = newValue&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Barrier-线程阻断"><a href="#Barrier-线程阻断" class="headerlink" title="Barrier 线程阻断"></a>Barrier 线程阻断</h3><p>假设我们有一个并发的队列用来读写一个数据对象。如果这个队列里的操作是读的，那么可以多个同时进行。如果有写的操作，则必须保证在执行写入操作时，不会有读取操作在执行，必须等待写入完成后才能读取，否则就可能会出现读到的数据不对。这个时候我们会用到 <code>Barrier</code>。</p><p><strong>以<code>barrier flag</code>提交的任务能够保证其在并行队列执行的时候，是唯一的一个任务。（只对自己创建的队列有效，对<code>gloablQueue</code>无效）</strong></p><p>我们写个例子来看看效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let concurrentQueue = DispatchQueue(label: &quot;com.leo.concurrent&quot;, attributes: .concurrent)</span><br><span class="line">concurrentQueue.async &#123;</span><br><span class="line">    readDataTask(label: &quot;1&quot;, cost: 3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">concurrentQueue.async &#123;</span><br><span class="line">    readDataTask(label: &quot;2&quot;, cost: 3)</span><br><span class="line">&#125;</span><br><span class="line">concurrentQueue.async(flags: .barrier, execute: &#123;</span><br><span class="line">    NSLog(&quot;Task from barrier 1 begin&quot;)</span><br><span class="line">    sleep(3)</span><br><span class="line">    NSLog(&quot;Task from barrier 1 end&quot;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">concurrentQueue.async &#123;</span><br><span class="line">    readDataTask(label: &quot;2&quot;, cost: 3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，看到Log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2017-01-06 17:14:19.690 Dispatch[15609:245546] Start data task1</span><br><span class="line">2017-01-06 17:14:19.690 Dispatch[15609:245542] Start data task2</span><br><span class="line">2017-01-06 17:14:22.763 Dispatch[15609:245546] End data task1</span><br><span class="line">2017-01-06 17:14:22.763 Dispatch[15609:245542] End data task2</span><br><span class="line">2017-01-06 17:14:22.764 Dispatch[15609:245546] Task from barrier 1 begin</span><br><span class="line">2017-01-06 17:14:25.839 Dispatch[15609:245546] Task from barrier 1 end</span><br><span class="line">2017-01-06 17:14:25.839 Dispatch[15609:245546] Start data task3</span><br><span class="line">2017-01-06 17:14:28.913 Dispatch[15609:245546] End data task3</span><br></pre></td></tr></table></figure><p>执行的效果就是：<code>barrier</code>任务提交后，等待前面所有的任务都完成了才执行自身。<code>barrier</code>任务执行完了后，再执行后续执行的任务。</p><h3 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore 信号量"></a>Semaphore 信号量</h3><p><code>DispatchSemaphore</code>是传统计数信号量的封装，<strong>用来控制资源被多任务访问的情况</strong>。</p><p>简单来说，如果我只有两个usb端口，如果来了三个usb请求的话，那么第3个就要等待，等待有一个空出来的时候，第三个请求才会继续执行。</p><p>我们来模拟这一情况:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public func usbTask(label:String, cost:UInt32, complete:@escaping ()-&gt;())&#123;</span><br><span class="line">    print(&quot;Start usb task%@&quot;,label)</span><br><span class="line">    sleep(cost)</span><br><span class="line">    print(&quot;End usb task%@&quot;,label)</span><br><span class="line">    complete()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let semaphore = DispatchSemaphore(value: 2)</span><br><span class="line">let queue = DispatchQueue(label: &quot;com.leo.concurrentQueue&quot;, qos: .default, attributes: .concurrent)</span><br><span class="line"></span><br><span class="line">queue.async &#123;</span><br><span class="line">    semaphore.wait()</span><br><span class="line">    usbTask(label: &quot;1&quot;, cost: 2, complete: &#123; </span><br><span class="line">        semaphore.signal()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue.async &#123;</span><br><span class="line">    semaphore.wait()</span><br><span class="line">    usbTask(label: &quot;2&quot;, cost: 2, complete: &#123;</span><br><span class="line">        semaphore.signal()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue.async &#123;</span><br><span class="line">    semaphore.wait()</span><br><span class="line">    usbTask(label: &quot;3&quot;, cost: 1, complete: &#123;</span><br><span class="line">        semaphore.signal()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2017-01-06 15:03:09.264 Dispatch[5711:162205] Start usb task2</span><br><span class="line">2017-01-06 15:03:09.264 Dispatch[5711:162204] Start usb task1</span><br><span class="line">2017-01-06 15:03:11.338 Dispatch[5711:162205] End usb task2</span><br><span class="line">2017-01-06 15:03:11.338 Dispatch[5711:162204] End usb task1</span><br><span class="line">2017-01-06 15:03:11.339 Dispatch[5711:162219] Start usb task3</span><br><span class="line">2017-01-06 15:03:12.411 Dispatch[5711:162219] End usb task3</span><br></pre></td></tr></table></figure><blockquote><p>Tips：在<code>serial queue</code>上使用信号量要注意死锁的问题。感兴趣的同学可以把上述代码的<code>queue</code>改成<code>serial</code>的，看看效果。</p></blockquote><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="http://www.cocoachina.com/ios/20160804/17291.html" target="_blank" rel="noopener">iOS多线程与GCD 你看我就够了</a></p><p><a href="http://blog.csdn.net/Hello_Hwc/article/details/54293280" target="_blank" rel="noopener">GCD精讲（Swift 3）</a></p><p><a href="http://www.jianshu.com/p/35dd92bcfe8c" target="_blank" rel="noopener">iOS多线程-各种线程锁的简单介绍</a></p><p><a href="http://www.jianshu.com/p/0b0d9b1f1f19" target="_blank" rel="noopener">关于iOS多线程，你看我就够了</a></p><p><a href="http://blog.csdn.net/u013672551/article/details/47396671" target="_blank" rel="noopener">IOS开发之多线程详解</a></p><p><a href="http://www.jianshu.com/p/fc78dab5736f" target="_blank" rel="noopener">Swift 3必看：从使用场景了解GCD新API</a></p><p><a href="http://www.jb51.net/article/75020.htm" target="_blank" rel="noopener">浅析iOS应用开发中线程间的通信与线程安全问题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;iOS多线程深入解析&quot;&gt;&lt;a href=&quot;#iOS多线程深入解析&quot; class=&quot;headerlink&quot; title=&quot;iOS多线程深入解析&quot;&gt;&lt;/a&gt;iOS多线程深入解析&lt;/h1&gt;&lt;h2 id=&quot;必要的概念&quot;&gt;&lt;a href=&quot;#必要的概念&quot; class=&quot;headerlink&quot; title=&quot;必要的概念&quot;&gt;&lt;/a&gt;必要的概念&lt;/h2&gt;&lt;h3 id=&quot;进程-线程&quot;&gt;&lt;a href=&quot;#进程-线程&quot; class=&quot;headerlink&quot; title=&quot;进程/线程&quot;&gt;&lt;/a&gt;进程/线程&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;：进程指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;：线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作系统引入进程的目的&lt;/strong&gt;：为了使多个程序能并发执行，以提高资源的利用率和系统的吞吐量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作系统引入线程的目的&lt;/strong&gt;：在操作系统中再引入线程，则是为了减少程序在并发执行时所付出的时空开销，使&lt;code&gt;OS&lt;/code&gt;具有更好的并发性。多线程技术可以提高程序的执行效率。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在引入线程的OS中，通常把进程作为资源分配的基本单位，而把线程作为独立运行和独立调度的基本单位。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开发" scheme="https://fightingjoey.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Swift" scheme="https://fightingjoey.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu Anaconda安装TensorFlow-GPU</title>
    <link href="https://fightingjoey.github.io/2017/10/22/%E6%95%99%E7%A8%8B/Ubuntu%20Anaconda%E5%AE%89%E8%A3%85TensorFlow-GPU/"/>
    <id>https://fightingjoey.github.io/2017/10/22/教程/Ubuntu Anaconda安装TensorFlow-GPU/</id>
    <published>2017-10-22T11:24:18.000Z</published>
    <updated>2018-09-27T02:08:22.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu-Anaconda安装TensorFlow-GPU"><a href="#Ubuntu-Anaconda安装TensorFlow-GPU" class="headerlink" title="Ubuntu Anaconda安装TensorFlow-GPU"></a>Ubuntu Anaconda安装TensorFlow-GPU</h1><p>目前时间是<code>2017.10.22</code>，目前的<code>CUDA</code>最新版本是<code>CUDA9</code>，<code>TensorFlow</code>的版本是<code>1.3</code>，一开始安装<code>CUDA9</code>，后来发现<code>TensorFlow</code>不支持，网上有人说可以通过源代码安装<code>TensorFlow</code>，但是我觉得太麻烦了，后来就换了<code>CUDA8</code>，中间遇到了很多版本不对应所产生的问题，下面详细列一下本次安装所使用的安装包的版本号：（亲测可安装成功）</p><ul><li>CUDA: <code>cuda-repo-ubuntu1604-8-0-local_8.0.44-1_amd64.deb</code></li><li>cudnn: <code>cudnn-8.0-linux-x64-v5.1.tar</code></li><li>Anaconda: <code>Anaconda3-5.0.0.1-Linux-x86_64.sh</code></li></ul><a id="more"></a><h2 id="一、安装准备"><a href="#一、安装准备" class="headerlink" title="一、安装准备"></a>一、安装准备</h2><p><a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="noopener">CUDA下载</a></p><p><a href="https://developer.nvidia.com/cudnn" target="_blank" rel="noopener">cudnn下载</a></p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="noopener">Anaconda下载</a></p><blockquote><p>在实际的安装过程中，发现目前最新的版本 Tensorflow 并不能支持，后来折腾了好久，才找到上面提到的那几个对应的安装包，<a href="https://pan.baidu.com/s/1gfAghUz" target="_blank" rel="noopener">百度网盘分享链接</a>，密码：<code>8lpv</code></p></blockquote><h2 id="二、安装-NVIDIA-驱动"><a href="#二、安装-NVIDIA-驱动" class="headerlink" title="二、安装 NVIDIA 驱动"></a>二、安装 NVIDIA 驱动</h2><p>首先打开 <code>terminal</code>，输入一下指令，更新应用列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>多亏了<code>Linux</code>社区的强大支持，我们可以用很简洁的方式安装驱动：</p><ul><li><p>按下<code>win</code>按键，打开菜单</p></li><li><p>然后在上方的<code>type to search</code>中输入：<code>additional drivers</code>打开 “<code>additional drivers —— 附加驱动</code>“，然后选择 与自己显卡匹配的<code>NVIDIA</code>驱动，我这里是 <code>using nvidia binary drivers (375)</code></p></li><li><p>然后选择 <strong>应用更改</strong>，这里安装可能会失败，此时你可以继续选择应用更改，多安装几次即可。</p></li><li><p>安装完成后，选择<code>restart</code></p></li></ul><h2 id="三、gcc-降版本"><a href="#三、gcc-降版本" class="headerlink" title="三、gcc 降版本"></a>三、gcc 降版本</h2><p><code>CUDA8.0</code>不支持<code>gcc 5.0</code>及以上的编译器，而系统自带的是<code>5.4</code>及以上版本，因此我们需要降版本，否则会在后面报错。</p><p>在<code>terminal</code>中输入如下指令，将<code>gcc</code>版本降到 4.9</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install g++-4.9</span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.9 20</span><br><span class="line">sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 10</span><br><span class="line">sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.9 20</span><br><span class="line">sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-5 10</span><br><span class="line">sudo update-alternatives --install /usr/bin/cc cc /usr/bin/gcc 30</span><br><span class="line">sudo update-alternatives --set cc /usr/bin/gcc</span><br><span class="line">sudo update-alternatives --install /usr/bin/c++ c++ /usr/bin/g++ 30</span><br><span class="line">sudo update-alternatives --set c++ /usr/bin/g++</span><br></pre></td></tr></table></figure><h2 id="四、安装-CUDA-8-0"><a href="#四、安装-CUDA-8-0" class="headerlink" title="四、安装 CUDA 8.0"></a>四、安装 CUDA 8.0</h2><p>进入<code>cuda</code>安装包所在文件夹，右键打开终端，在终端中输入以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 根据官网上的提示安装 cuda 8.0</span><br><span class="line">sudo dpkg -i cuda-repo-ubuntu1604-8-0-local_8.0.44-1_amd64.deb</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install cuda​</span><br></pre></td></tr></table></figure><h2 id="五、安装-cudnn"><a href="#五、安装-cudnn" class="headerlink" title="五、安装 cudnn"></a>五、安装 cudnn</h2><p>把<code>cudnn-8.0-linux-x64-v5.1.tar</code>解压，右键打开终端，在终端中输入以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo cp cuda/include/cudnn.h /usr/local/cuda/include # 复制到 include 中</span><br><span class="line">sudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64 # 复制到 lib64 中</span><br><span class="line">sudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn* # 将头文件复制进去</span><br></pre></td></tr></table></figure><h2 id="六、配置CUDA环境变量"><a href="#六、配置CUDA环境变量" class="headerlink" title="六、配置CUDA环境变量"></a>六、配置CUDA环境变量</h2><p>开启 GPU 支持：</p><p>根据官网教程，我们在<code>terminal</code>中键入下列命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit ~/.bash_profile # 打开.bash_profile 这是用户的环境变量，不是全局的</span><br></pre></td></tr></table></figure><p>然后在打开的文本末尾加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=&quot;$LD_LIBRARY_PATH:/usr/local/cuda/lib64:/usr/local/cuda/extras/CUPTI/lib64&quot;</span><br><span class="line">export CUDA_HOME=/usr/local/cuda</span><br></pre></td></tr></table></figure><p>保存并关闭后，输入下列命令使环境变量生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile # 使被更改的环境变量生效</span><br></pre></td></tr></table></figure><p>安装完成后，一定要通过如下两条命令对驱动进行检验：</p><ol><li><p><code>NVIDIA</code>的设置界面</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-settings # 打开 NVIDIA 设置界面</span><br></pre></td></tr></table></figure></li></ol><p><img src="http://upload-images.jianshu.io/upload_images/1507703-7285e15ffef6070d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NVIDIA设置.png"></p><ol start="2"><li><p><code>NVIDIA GPU</code>列表</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi # 这条指令会在 terminal 中产生GPU列表</span><br></pre></td></tr></table></figure></li></ol><p><img src="http://upload-images.jianshu.io/upload_images/1507703-58835500654151cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GPU列表.png"></p><blockquote><p>网上有些人抄别人的博客，说<code>nvcc -V</code>就可以验证，经过大神实测，存在<code>nvcc -V</code>正常输出但是驱动仍安装失败的现象，因此，上述验证方法是不可信的。</p></blockquote><h2 id="七、安装Anaconda"><a href="#七、安装Anaconda" class="headerlink" title="七、安装Anaconda"></a>七、安装Anaconda</h2><p>进入<code>anaconda</code>安装包所在目录，打开终端，根据版本输入安装命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash Anaconda3-5.0.0.1-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><p>回车后，是许可文件，接收许可，<code>anaconda</code>将安装在<code>~/anaconda</code>目录下，直接回车就好。</p><p>最后会询问是否把<code>anaconda</code>的<code>bin</code>添加到用户的环境变量中，选择<code>yes</code>。</p><p>安装成功以后，在终端输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><p>让<code>.bashrc</code>中添加的路径生效。</p><p>当然，你也可以手动完成环境变量的修改：</p><ul><li><p>首先打开环境变量的文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit ~/.bashrc</span><br></pre></td></tr></table></figure></li><li><p>然后在文件末尾加入 anaconda3 的路径</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/home/你的路径/anaconda3/bin:$PATH</span><br></pre></td></tr></table></figure></li><li><p>最后使我们的改动生效</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></li></ul><p>这样，我们在<code>terminal</code>中输入<code>python</code>就会默认打开<code>anaconda3</code>里默认的<code>python</code>了</p><h2 id="八、安装Tensorflow-GPU"><a href="#八、安装Tensorflow-GPU" class="headerlink" title="八、安装Tensorflow-GPU"></a>八、安装Tensorflow-GPU</h2><p>创建<code>Tensorflow</code>的运行环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n tensorflow python=3.5</span><br></pre></td></tr></table></figure><p>激活环境,使用 pip 安装 TensorFlow-GPU</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source activate tensorflow</span><br><span class="line">pip install tensorflow-gpu keras # 安装 gpu 版本的 tensorflow 和 keras</span><br></pre></td></tr></table></figure><p>安装完成后，我们使用如下命令，即可检验是否成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &quot;import keras&quot;</span><br></pre></td></tr></table></figure><p>如果看到如下输出，就说明安装成功</p><p><img src="http://upload-images.jianshu.io/upload_images/1507703-a2e9946aefe571ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="安装成功输出.png"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.cnblogs.com/luruiyuan/p/6660142.html" target="_blank" rel="noopener">Ubuntu 安装 tensorflow-gpu + keras</a></p><p><a href="http://www.52nlp.cn/tag/cuda-9-0" target="_blank" rel="noopener">Ubuntu17.04+Nvidia GTX 1080+CUDA 9.0+cuDNN 7.0+TensorFlow 1.3</a></p><p><a href="http://blog.csdn.net/shengchun75/article/details/78174388" target="_blank" rel="noopener">CUDA 9.0 + cuDNN 7.0 + Tensorflow源码编译</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Ubuntu-Anaconda安装TensorFlow-GPU&quot;&gt;&lt;a href=&quot;#Ubuntu-Anaconda安装TensorFlow-GPU&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu Anaconda安装TensorFlow-GPU&quot;&gt;&lt;/a&gt;Ubuntu Anaconda安装TensorFlow-GPU&lt;/h1&gt;&lt;p&gt;目前时间是&lt;code&gt;2017.10.22&lt;/code&gt;，目前的&lt;code&gt;CUDA&lt;/code&gt;最新版本是&lt;code&gt;CUDA9&lt;/code&gt;，&lt;code&gt;TensorFlow&lt;/code&gt;的版本是&lt;code&gt;1.3&lt;/code&gt;，一开始安装&lt;code&gt;CUDA9&lt;/code&gt;，后来发现&lt;code&gt;TensorFlow&lt;/code&gt;不支持，网上有人说可以通过源代码安装&lt;code&gt;TensorFlow&lt;/code&gt;，但是我觉得太麻烦了，后来就换了&lt;code&gt;CUDA8&lt;/code&gt;，中间遇到了很多版本不对应所产生的问题，下面详细列一下本次安装所使用的安装包的版本号：（亲测可安装成功）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CUDA: &lt;code&gt;cuda-repo-ubuntu1604-8-0-local_8.0.44-1_amd64.deb&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cudnn: &lt;code&gt;cudnn-8.0-linux-x64-v5.1.tar&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Anaconda: &lt;code&gt;Anaconda3-5.0.0.1-Linux-x86_64.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="教程" scheme="https://fightingjoey.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Linux" scheme="https://fightingjoey.github.io/tags/Linux/"/>
    
      <category term="深度学习" scheme="https://fightingjoey.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>制作Mac系统盘</title>
    <link href="https://fightingjoey.github.io/2017/10/21/%E6%95%99%E7%A8%8B/%E5%88%B6%E4%BD%9CMac%E7%B3%BB%E7%BB%9F%E7%9B%98/"/>
    <id>https://fightingjoey.github.io/2017/10/21/教程/制作Mac系统盘/</id>
    <published>2017-10-21T10:35:00.000Z</published>
    <updated>2018-09-27T02:08:41.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、准备工作："><a href="#一、准备工作：" class="headerlink" title="一、准备工作："></a>一、准备工作：</h2><ul><li>准备一个<code>8GB</code>或以上容量的<code>U</code>盘，确保里面的数据已经妥善备份好（该过程会抹掉 U 盘全部数据）</li><li>首先，从<code>AppSotre</code>下载<code>macOS</code>原版安装包。目前是<code>macOS High Sierra.app</code></li></ul><h2 id="二、格式化优盘"><a href="#二、格式化优盘" class="headerlink" title="二、格式化优盘"></a>二、格式化优盘</h2><ul><li>插入你的 U 盘，然后在「应用程序」-&gt;「实用工具」里面找到并打开「磁盘工具」</li><li>在左方列表中找到 U 盘的名称并点击</li><li>右边顶部选择「分区」，然后在「分区布局」选择「1个分区」</li><li>在分区信息中的 「名称」输入「ABCD」 (由于后面的命令中会用到此名称，如果你要修改成其他(英文)，请务必对应修改后面的命令)</li><li>在「格式」中选择 「Mac OS 扩展 (日志式)」</li><li>这时，先别急着点“应用”，还要先在 「选项」里面，选择「GUID 分区表」</li><li>开始格式化</li></ul><a id="more"></a><h2 id="三、输入终端命令开始制作启动盘"><a href="#三、输入终端命令开始制作启动盘" class="headerlink" title="三、输入终端命令开始制作启动盘"></a>三、输入终端命令开始制作启动盘</h2><ul><li>请再次确保安装文件是保存在「应用程序」的目录中</li><li>在「应用程序」-&gt;「实用工具」里面找到「终端」并打开。也可以直接通过 Spotlight 搜索「终端」打开</li><li>复制下面的命令，并粘贴到「终端」里，按回车运行：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /Applications/Install\ macOS\ High\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/restart --applicationpath /Applications/Install\ macOS\ High\ Sierra.app --nointeraction</span><br></pre></td></tr></table></figure><blockquote><p>命令说明：Install\ macOS\ High\ Sierra.app 这个是正式版的“安装 macOS High Sierra” 正确位置.</p><p>restart 这个是优盘的名字</p></blockquote><p>回车后，系统会提示你输入管理员密码，接下来就是等待系统开始制作启动盘了。这时，命令执行中你会陆续看到类似以下的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Erasing Disk: 0%... 10%... 20%... 30%...100%...</span><br><span class="line">Copying installer files to disk...</span><br><span class="line">Copy complete.</span><br><span class="line">Making disk bootable...</span><br><span class="line">Copying boot files...</span><br><span class="line">Copy complete.</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure><p>当你看到最后有 「Copy complete」和「Done」 字样出现就是表示启动盘已经制作完成了！</p><h2 id="四、U-盘启动安装-macOS-Sierra-的方法"><a href="#四、U-盘启动安装-macOS-Sierra-的方法" class="headerlink" title="四、U 盘启动安装 macOS Sierra 的方法"></a>四、U 盘启动安装 macOS Sierra 的方法</h2><p>当你插入制作完成的<code>macOS Sierra U盘</code>启动盘之后，桌面出现<code>「Install macOS Sierra」</code>的盘符那么就表示启动盘是正常的了。那么怎样通过<code>USB</code>启动进行全新的系统安装呢？</p><p>其实很简单，先在目标电脑上插上<code>U</code>盘，然后重启你的<code>Mac</code>，然后一直按住<code>「option」(alt)</code>按键不放，直到屏幕显示多出一个<code>USB</code>启动盘的选项。</p><p>这时选择<code>U</code>盘的图标回车，即可通过<code>U</code>盘来安装<code>macOS Sierra</code>了！这时，你可以直接覆盖安装系统(升级)，也可以在磁盘工具里面格式化抹掉整个硬盘，或者重新分区等实现全新的干净的安装。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、准备工作：&quot;&gt;&lt;a href=&quot;#一、准备工作：&quot; class=&quot;headerlink&quot; title=&quot;一、准备工作：&quot;&gt;&lt;/a&gt;一、准备工作：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;准备一个&lt;code&gt;8GB&lt;/code&gt;或以上容量的&lt;code&gt;U&lt;/code&gt;盘，确保里面的数据已经妥善备份好（该过程会抹掉 U 盘全部数据）&lt;/li&gt;
&lt;li&gt;首先，从&lt;code&gt;AppSotre&lt;/code&gt;下载&lt;code&gt;macOS&lt;/code&gt;原版安装包。目前是&lt;code&gt;macOS High Sierra.app&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;二、格式化优盘&quot;&gt;&lt;a href=&quot;#二、格式化优盘&quot; class=&quot;headerlink&quot; title=&quot;二、格式化优盘&quot;&gt;&lt;/a&gt;二、格式化优盘&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;插入你的 U 盘，然后在「应用程序」-&amp;gt;「实用工具」里面找到并打开「磁盘工具」&lt;/li&gt;
&lt;li&gt;在左方列表中找到 U 盘的名称并点击&lt;/li&gt;
&lt;li&gt;右边顶部选择「分区」，然后在「分区布局」选择「1个分区」&lt;/li&gt;
&lt;li&gt;在分区信息中的 「名称」输入「ABCD」 (由于后面的命令中会用到此名称，如果你要修改成其他(英文)，请务必对应修改后面的命令)&lt;/li&gt;
&lt;li&gt;在「格式」中选择 「Mac OS 扩展 (日志式)」&lt;/li&gt;
&lt;li&gt;这时，先别急着点“应用”，还要先在 「选项」里面，选择「GUID 分区表」&lt;/li&gt;
&lt;li&gt;开始格式化&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="教程" scheme="https://fightingjoey.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Mac" scheme="https://fightingjoey.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>适配iOS11（常用）</title>
    <link href="https://fightingjoey.github.io/2017/09/29/%E5%BC%80%E5%8F%91/%E9%80%82%E9%85%8DiOS11%EF%BC%88%E5%B8%B8%E7%94%A8%EF%BC%89/"/>
    <id>https://fightingjoey.github.io/2017/09/29/开发/适配iOS11（常用）/</id>
    <published>2017-09-29T09:24:28.000Z</published>
    <updated>2018-09-27T02:10:49.210Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导航栏变化"><a href="#导航栏变化" class="headerlink" title="导航栏变化"></a>导航栏变化</h3><h4 id="高度变化"><a href="#高度变化" class="headerlink" title="高度变化"></a>高度变化</h4><p>在iOS11中导航栏多了一个<code>LargeTitleView</code>，专门专门显示大字标题。该<code>LargeTitleView</code>的高度为<strong>52p</strong>。</p><ul><li>iPhoneX之前的机型，默认高度<strong>64p</strong>，如果显示大字标题，总高度为<strong>20+44+52=116p</strong></li><li>iPhoneX，<strong>statusbar=44</strong>，默认高度<strong>88p</strong>，如果显示大字标题，总高度为<strong>44+44+52=140p</strong></li></ul><blockquote><p>iPhoneX底部还多了一个半角的矩形，使得tabbar多出来了<strong>34p</strong>的高度</p></blockquote><a id="more"></a><p><strong>控制大标题的显示</strong></p><p>在<code>UINavigationBar</code>中新增了一个BOOL属性<code>prefersLargeTitles</code>,将该属性设置为<code>ture</code>，<code>NavigationBar</code>就会在整个APP中显示大标题，如果想要在控制不同页面大标题的显示，可以通过设置当前页面的<code>navigationItem</code>的<code>largeTitleDisplayMode</code>属性；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">navigationItem.largeTitleDisplayMode </span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSInteger, UINavigationItemLargeTitleDisplayMode) &#123;  </span><br><span class="line">/// 自动模式，依赖上一个 item 的特性</span><br><span class="line">UINavigationItemLargeTitleDisplayModeAutomatic,</span><br><span class="line">/// 针对当前 item 总是启用大标题特性</span><br><span class="line">UINavigationItemLargeTitleDisplayModeAlways,</span><br><span class="line">/// Never 不启用大标题特性</span><br><span class="line">UINavigationItemLargeTitleDisplayModeNever,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="导航栏内视图边距变化"><a href="#导航栏内视图边距变化" class="headerlink" title="导航栏内视图边距变化"></a>导航栏内视图边距变化</h4><p>在iOS11系统中</p><ul><li>设置了<code>TitleView</code>：<ul><li><code>iPhone6P</code>以上：左右边距为<strong><code>12pt</code></strong></li><li><code>iPhone6P</code>以下：左右边距为<strong><code>8pt</code></strong></li></ul></li><li>设置了左右<code>navigationBarButton</code>：<ul><li><code>iPhone6P</code>以上：左右边距为<strong><code>20pt</code></strong></li><li><code>iPhone6P</code>以下：左右边距为<strong><code>16pt</code></strong></li></ul></li><li>同时设置了<code>TitleView</code>和<code>navigationBarButton</code>：<ul><li><code>iPhone6P</code>以上：<code>navigationBarButton</code>的左右边距为<strong><code>20pt</code></strong>，<code>navigationBarButton</code>与<code>TitleView</code>间距为<strong><code>0pt</code></strong></li><li><code>iPhone6P</code>以下：<code>navigationBarButton</code>的左右边距为<strong><code>16pt</code></strong>，<code>navigationBarButton</code>与<code>TitleView</code>间距为<strong><code>0pt</code></strong></li></ul></li></ul><h3 id="automaticallyAdjustsScrollViewInsets-属性"><a href="#automaticallyAdjustsScrollViewInsets-属性" class="headerlink" title="automaticallyAdjustsScrollViewInsets 属性"></a>automaticallyAdjustsScrollViewInsets 属性</h3><p>iOS 11 后 <code>UIViewController</code> 的属性 <code>automaticallyAdjustsScrollViewInsets</code>，变为了 <code>UIScrollView&#39;s contentInsetAdjustmentBehavior</code>。如果发现界面无意中位置偏移了，很可能是这个属性导致的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (@available(iOS 11.0, *)) &#123;</span><br><span class="line">   [UIScrollView appearance].contentInsetAdjustmentBehavior =UIScrollViewContentInsetAdjustmentNever;</span><br><span class="line">   //iOS11 解决SafeArea的问题，同时能解决pop时上级页面scrollView抖动的问题</span><br><span class="line">&#125; else &#123;</span><br><span class="line">   self.automaticallyAdjustsScrollViewInsets = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TableViews-：在iOS-11中默认启用Self-Sizing"><a href="#TableViews-：在iOS-11中默认启用Self-Sizing" class="headerlink" title="TableViews ：在iOS 11中默认启用Self-Sizing"></a>TableViews ：在iOS 11中默认启用Self-Sizing</h3><p>在iOS11中，默认开启了<code>Self-Sizing</code>估算行高机制，我们可以通过实现<code>estimatedRowHeight</code>相关的属性来展示动态的内容，实现了<code>estimatedRowHeight</code>属性后，得到的初始<code>contenSize</code>是个估算值，是通过<code>estimatedRowHeight</code> * <code>cell</code>的个数得到的，并不是最终的<code>contenSize</code>，<code>tableView</code>不会一次性计算所有的<code>cell</code>的高度了，只会计算当前屏幕能够显示的<code>cell</code>个数再加上几个，滑动时，<code>tableView</code>不停地得到新的<code>cell</code>，更新自己的<code>contenSize</code>，在滑到最后的时候，会得到正确的<code>contenSize</code>。</p><p><code>Self-Sizing</code>在iOS11下是默认开启的，<code>Headers</code>,<code>footers</code>, <code>and cells</code>都默认开启<code>Self-Sizing</code>，所有<code>estimated</code> 高度默认值从<code>iOS11</code>之前的 0 改变为<code>UITableViewAutomaticDimension</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic) CGFloat estimatedRowHeight NS_AVAILABLE_IOS(7_0); </span><br><span class="line">// default is UITableViewAutomaticDimension, set to 0 to disable</span><br></pre></td></tr></table></figure><p>如果目前项目中没有使用<code>estimateRowHeight</code>属性，在<code>iOS11</code>的环境下就要注意了，因为开启<code>Self-Sizing</code>之后，<code>tableView</code>是使用<code>estimateRowHeight</code>属性的，这样就会造成<code>contentSize</code>和<code>contentOffset</code>值的变化，如果是有动画是观察这两个属性的变化进行的，就会造成动画的异常，因为在估算行高机制下，<code>contentSize</code>的值是一点点地变化更新的，所有<code>cell</code>显示完后才是最终的<code>contentSize</code>值。因为不会缓存正确的行高，<code>tableView reloadData</code>的时候，会重新计算<code>contentSize</code>，就有可能会引起<code>contentOffset</code>的变化。<code>iOS11</code>下不想使用<code>Self-Sizing</code>的话，可以通过以下方式关闭：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[UITableView appearance].estimatedRowHeight = 0;</span><br><span class="line">[UITableView appearance].estimatedSectionHeaderHeight = 0;</span><br><span class="line">[UITableView appearance].estimatedSectionFooterHeight = 0;</span><br></pre></td></tr></table></figure><p><code>iOS11</code>下，如果没有设置<code>estimateRowHeight</code>的值，也没有设置<code>rowHeight</code>的值，那<code>contentSize</code>计算初始值是 <code>44 * cell</code>的个数.</p><blockquote><p>在iOS11之前，可以只实现<code>heightForHeaderInSection</code>方法，而不实现<code>viewForHeaderInSection</code>方法，但实际上这样写是不规范的，只实现了高度，没有实现View，在iOS11中，这样写就会出现问题。</p></blockquote><h3 id="TableViews：separatorInset-扩展"><a href="#TableViews：separatorInset-扩展" class="headerlink" title="TableViews：separatorInset 扩展"></a>TableViews：separatorInset 扩展</h3><p><code>iOS 7</code> 引入<code>separatorInset</code>属性，用以设置<code>cell</code>的分割线边距，在 <code>iOS 11</code> 中对其进行了扩展。可以通过新增的<code>UITableViewSeparatorInsetReference</code>枚举类型的<code>separatorInsetReference</code>属性来设置<code>separatorInset</code>属性的参照值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UITableViewSeparatorInsetReference) &#123;  </span><br><span class="line">    UITableViewSeparatorInsetFromCellEdges,   //默认值，表示separatorInset是从cell的边缘的偏移量</span><br><span class="line">    UITableViewSeparatorInsetFromAutomaticInsets  //表示separatorInset属性值是从一个insets的偏移量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AppIcon"><a href="#AppIcon" class="headerlink" title="AppIcon"></a>AppIcon</h3><p>多了一个<code>AppIcon</code>，1024*1024</p><h3 id="LanchImage"><a href="#LanchImage" class="headerlink" title="LanchImage"></a>LanchImage</h3><p>多了一个iPhoneX</p><h3 id="iPhoneX"><a href="#iPhoneX" class="headerlink" title="iPhoneX"></a>iPhoneX</h3><ol><li><code>iPhoneX</code>的状态栏由原来的 20 变为了 44。这个如果在导航的位置设置自定义的<code>View</code>，在<code>iPhoneX</code>上出问题。会挡住<code>View</code>的显示。</li><li>启动页，如果使用<code>LaunchScreen.storyboard</code>作为启动页，需要调整下<code>Top</code>的约束，以前为 -20 ，改为 -44 ；</li></ol><blockquote><p>iPhoneX 分辨率： 1125*2436 ，458 ppi</p></blockquote><h3 id="访问相册权限"><a href="#访问相册权限" class="headerlink" title="访问相册权限"></a>访问相册权限</h3><p><code>iOS11</code> 以后使用 <code>NSPhotoLibraryAddUsageDescription</code></p><p><code>iOS11</code> 之前使用的是 <code>NSPhotoLibraryUsageDescription</code></p><p>详见：<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW17" target="_blank" rel="noopener">Cocoa Keys</a></p><h3 id="屏幕尺寸变化"><a href="#屏幕尺寸变化" class="headerlink" title="屏幕尺寸变化"></a>屏幕尺寸变化</h3><ul><li>{375, 812} iPhone X</li><li>{375, 667} iPhone 8 / iPhone 7 ／ iPhone 6</li><li>{414, 736} iPhone 8P / iPhone 7P / iPhone 6P</li><li>{320, 568} iPhone SE / iPhone 5</li></ul><h3 id="设备号变化"><a href="#设备号变化" class="headerlink" title="设备号变化"></a>设备号变化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">case &quot;iPhone10,1&quot;, &quot;iPhone10,4&quot;:</span><br><span class="line">      return &quot;iPhone 8&quot;</span><br><span class="line">case &quot;iPhone10,2&quot;, &quot;iPhone10,5&quot;:</span><br><span class="line">      return &quot;iPhone 8 Plus&quot;</span><br><span class="line">case &quot;iPhone10,3&quot;, &quot;iPhone10,6&quot;:</span><br><span class="line">      return &quot;iPhone X&quot;</span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://www.jianshu.com/p/370d82ba3939" target="_blank" rel="noopener">你可能需要为你的APP适配iOS11</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;导航栏变化&quot;&gt;&lt;a href=&quot;#导航栏变化&quot; class=&quot;headerlink&quot; title=&quot;导航栏变化&quot;&gt;&lt;/a&gt;导航栏变化&lt;/h3&gt;&lt;h4 id=&quot;高度变化&quot;&gt;&lt;a href=&quot;#高度变化&quot; class=&quot;headerlink&quot; title=&quot;高度变化&quot;&gt;&lt;/a&gt;高度变化&lt;/h4&gt;&lt;p&gt;在iOS11中导航栏多了一个&lt;code&gt;LargeTitleView&lt;/code&gt;，专门专门显示大字标题。该&lt;code&gt;LargeTitleView&lt;/code&gt;的高度为&lt;strong&gt;52p&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iPhoneX之前的机型，默认高度&lt;strong&gt;64p&lt;/strong&gt;，如果显示大字标题，总高度为&lt;strong&gt;20+44+52=116p&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;iPhoneX，&lt;strong&gt;statusbar=44&lt;/strong&gt;，默认高度&lt;strong&gt;88p&lt;/strong&gt;，如果显示大字标题，总高度为&lt;strong&gt;44+44+52=140p&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;iPhoneX底部还多了一个半角的矩形，使得tabbar多出来了&lt;strong&gt;34p&lt;/strong&gt;的高度&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="开发" scheme="https://fightingjoey.github.io/categories/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS" scheme="https://fightingjoey.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
